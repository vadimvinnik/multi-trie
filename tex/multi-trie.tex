%-------------------------------------------------------------------
%
% Author    : Vadim Vinnik
% E-mail    : vadim.vinnik@gmail.com
% Date      : 2015-12-03
% Status    : Draft
% License   : Creative commons
% Keywords  : name, value, map, trie, multi-set, haskell, monad
%
% Summary
% A ``trie of multisets'' is defined as a mathematical concept that
% reflects some aspects of structured data objects in programming;
% Properties thereof are investigated; An implementation in Haskell
% is described.
%
%-------------------------------------------------------------------

\documentclass{article}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{Df}{Definition}
\newtheorem{Th}{Theorem}
\newtheorem{Pf}{Proof}
\newtheorem{Rm}{Remark}

\newcommand{\mtempty}{\bot}
\newcommand{\mtfull}{\top}
\newcommand{\set}[1]{\mathcal{#1}}
\newcommand{\setmt}[2]{\set{M}_{#1,#2}}
\newcommand{\flatten}{\mathrm{Fl}}
\newcommand{\select}{\mathrm{Sel}}
\newcommand{\singleleaf}{\mathrm{Sg}}

\title{Tries of multisets, their properties, applications and implementation}
\author{Vadim Vinnik}
\date{2015}

\begin{document}

\maketitle

\begin{abstract}
A ``trie of multisets'' is defined as a mathematical concept that
reflects some aspects of structured data objects in programming;
Properties thereof are investigated; An implementation in Haskell
is described.
\end{abstract}

\tableofcontents

\section{Introduction}

%todo:
Why naming is so important. Why its formalisation is needed.

Suppose there is a given set~$D$ whose elements are called \emph{values}, or
\emph{denotata}, and a set~$V$ of objects called \emph{names}.

A quite natural formalisation of \emph{naming} as a relation between names and
their values is the following
\begin{Df}\label{def:naming-set}
A \emph{naming set} is a partial mapping $s: V\to D$.\qed
\end{Df}

In other words, a naming set is an object of the form
\[
  s = \{ (v_1, d_1), (v_2, d_2), \ldots, \} ,
\]
where $v_i\in V$, $d_i\in D$ and all names~$v_i$ are pairwise distinct. The
latter requirement formalizes \emph{unambiguity}, or \emph{univaluedness}: a
name cannot have different values in a given context.

Naming mappings defined as above are widely used in theoretical computer
science for syntactical as well as semantical tasks. Maps as direct
implementations of naming sets are included into standard libraries of various
programming languages and platforms and widely used in practice.

At the topmost abstraction level, a naming set represents a ``plain''
relation where names and values are atomic in the sense that their internal
structures and any non-trivial properties are hidden as irrelevant. In
fact, the only special property taken into account by the definition above is
equatability of names: for any two names it should be possible to decide
whether they are identical.

Introducing various properties of names and/or denotata, one can obtain a
number of interesting and useful specialised formalisations of naming for
theoretical purposes as well as data structures implementing them.
This article describes a case when
\begin{itemize}
\item names form a monoid, i.e. compound names can be concatenated from
simpler ones;
\item values are sets (replaced by sequences in the implementation).
\end{itemize}

\section{Abstract definition and basic properties}

If~$X$ is a set, let~$X^\ast$ denote a set of all sequences of its elements
(also known as \emph{chains}), and~$2^X$ be a set of all its subsets.
If~$a,b\in X^\ast$ are two chains, their concatenation will be denoted simply
as~$ab$. Let~$\varepsilon$ stand for the empty chain.

Let~$V$ be a given set of objects called \emph{atomic names}. Elements
of~$V^\ast$ are called \emph{compound names}. Let us omit the words ``atomic''
and ``compound'' if it does not lead to confusion.

% todo: raname MTs here
\begin{Df}\label{def:multitrie-abstract}
A \emph{$(V,D)$-multitrie} is a binary relation
\[
  p \subseteq V^\ast \times D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``multitrie''. A set of $(V,D)$-multitries will be
denoted~$\setmt{V}{D}$.\qed
\end{Df}

Therefore, there are two differences from the definition~\ref{def:naming-set}:
\begin{itemize}
\item multivaluedness: any name in a multitrie can be related to zero or more
values;
\item compoundness of names: names have some internal structure.
\end{itemize}

Obviously, a set of $(V,D)$-multitries is closed against set-theoretical union
and intersection.

In a univalued case, dereference a name means to find its only value, if any.
In a similar way, the following operation finds all values of a name, no matter
how many.

\begin{Df}\label{def:dereferencing}
Given a multitrie~$p$ and a name~$v\in V^\ast$, \emph{dereferencing} of~$v$
in~$p$ is
\[
  p(v) = \{ d | (v,d) \in p \} . \qedhere
\]
\end{Df}

Dereferencing distributes over set-theoretical operations:
Let~$\odot$ stand for either~$\cup$ or~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-multitries. Then
\[
  (p\odot q)(v) = p(v) \odot q(v) ,
\]
for every~$v\in V^\ast$.

Let us introduce special terms and symbols for the two extreme cases of
multitries, namely:
\begin{itemize}
\item \emph{Empty} $\bot = \varnothing$;
\item \emph{Full} $\top = V^\ast \times D$.
\end{itemize}
In other words, $\bot(v) = \varnothing$ and $\top(v) = D$ for
every~$v\in V^\ast$. Obviously,~$\bot$ and~$\top$ are neutral elements
of~$\cup$ and~$\cap$ operations, respectively.

Note that a compound name~$v$ in a multitrie~$p$ not only is a reference to
multiple values but also is a common root for a ``bunch'' of names starting
with~$v$. In this sence,~$v$ is a name for the entire sub-multitrie that is
formalised in the following
\begin{Df}\label{def:select-abstract}
Let~$p\in\setmt{V}{D}$, $v\in V^\ast$, then
\[
  \select(p,v) = \{ (w, d) \mid (vw, d)\in p \} .
\]
\end{Df}

Obviously,
\begin{itemize}
\item $\select(p,\varepsilon) = p$ for any multitrie~$p$;
\item $\select(p,uv) = \select(\select(p,u), v)$
  for any~$p\in\setmt{V}{D}$, $u,v\in V^\ast$;
\item $\select(p\odot q, v) = \select(p,v)\odot \select(q,v)$
  for any~$p,q\in\setmt{V}{D}$, $v\in V^\ast$, $\odot\in\{\cup, \cap\}$.
\end{itemize}

The next section presents another formalization of the multivalued naming that
is, however, equivalent to the above definitions.

\section{Alternative definition}

% todo: raname MTs here
\begin{Df}
A \emph{$(V,D)$-multitrie} is a total mapping
\[
  p : V^\ast \to 2^D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``multitrie''. A set of $(V,D)$-multitries will be
denoted~$\setmt{V}{D}$.\qed
\end{Df}

In other words, a multitrie could be regarded as a naming set whose names are
compound names and denotata are sets of objects from~$D$. The only special
detail here is totality of~$p$: every compound name has some value.

\begin{Df}
A multitrie~$p$ is called \emph{empty} (\emph{full}) and denoted~$\mtempty$
(respectively,~$\mtfull$) if $p(v)=\varnothing$ (resp., $p(v)=D$) for any~$v\in
N^\ast$.
\end{Df}

\begin{Df}
Let~$v$ be some compound name and~$A$ be some set of values, $v\in V^\ast$,
$A\subseteq D$.  Then~$p = \singleleaf(v,A)$ is such a multitrie that~$p(v) =
A$ and~$p(u) = \varnothing$ for any $u\in V^\ast$, $u\neq v$.
\end{Df}

\begin{Df}\label{def:select}
Let~$p\in\setmt{V}{D}$, $v\in V^\ast$, then
\[
  \select(p,v) = \{ (w, p(vw)) \mid w\in V^\ast \} .\qedhere
\]
\end{Df}

Obviously, for any multi-trie~$p$ and compound names~$u,v$:
\begin{eqnarray*}
  & \select(p,\varepsilon) = p ,\\
  & \select(p,uv) = \select(\select(p,u), v) .
\end{eqnarray*}

Operations similar to those of set theory can be naturally defined for multitries.

\begin{Df}\label{def:union-intersection}
Let~$\odot$ stand for any of~$\cup$ and~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-multitries. Then their \emph{union} and \emph{intersection} are
$(V,D)$-multitries, such that
\[
  (p\odot q)(v) = p(v) \odot q(v) ,
\]
for every~$v\in V^\ast$.\qed
\end{Df}

Obviously, empty and full multitries are neutral elements of union and intersection,
respectively. These operations are commutative, associative and idempotent.
Moreover, these operations are distributive against selection:
\[
  \select(p\odot q, v) = \select(p, v) \odot \select(q, v) .
\]

\begin{Df}\label{def:cartesian}
Let~$p$ and~$q$ be $(V,D')$- and $(V,D'')$-multitries, respectively. Their
\emph{cartesian product} $p\times q = r$ is a $(V,D'\times D'')$-multitrie
such that
\[
  r(w) = \bigcup_{u,v\in V^\ast: uv = w} p(u) \times q(v)
\]
for any~$w\in V^\ast$.\qed
\end{Df}

Obviously,~$\times$ is distributive against $\cap$ and $\cup$:
\[
  p\times(q\dot r) = p\times(q\dot r)
\]

Consider a multitrie whose values are, in their turn, multitries.
Flattening operation formally defined below turns it into a ``plain'' multitrie.
\begin{Df}\label{def:flatten}
\emph{Flattening} is an unary operation $\flatten : \setmt{V}{\setmt{V}{D}}
\to\setmt{V}{D}$, such that, for any $(V,\setmt{V}{D})$-multitrie~$p$, the
corresponding $r=\flatten(p)$ is defined by
\[
  r(w) = \bigcup_{u,v\in V^\ast: uv = w} p(u)(v)
\]
for any name~$w\in V^\ast$.\qed
\end{Df}

It is easy to see that the above definitions are equivalent to the following:
\begin{eqnarray}
  \label{eq:alt-cartesian}
  p\times q =
    \bigcup_{u,v\in V^\ast} \singleleaf(uv, p(u) \times q(v)) ,\\
  \label{eq:alt-flatten}
  \flatten(p) =
    \bigcup_{u,v\in V^\ast} \singleleaf(uv, p(u)(v)) .
\end{eqnarray}
(note that~$\cup$ in the definitions~\ref{def:cartesian} and~\ref{def:flatten}
means a set-theoretical union whereas in~(\ref{eq:alt-cartesian})
and~(\ref{eq:alt-flatten}) it means union of multitries, see
def.~\ref{def:union-intersection}).

\section{Constructional approach}

The above definition is abstract in the sense that it only describes how do
multitries look like from outside~-- namely, as a correspondence between
compound names and their values.

\section{Notes about implementation}

\section{Application}

\end{document}

