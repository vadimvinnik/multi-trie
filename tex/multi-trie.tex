%-------------------------------------------------------------------
%
% Author    : Vadim Vinnik
% E-mail    : vadim.vinnik@gmail.com
% Date      : 2016-03-29
% Status    : Draft
% License   : Creative commons
%
%-------------------------------------------------------------------

\documentclass{article}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{dirtree}

\DTsetlength{0.2em}{2em}{0.2em}{0.4pt}{1pt}

\theoremstyle{definition}
\newtheorem{Df}{Definition}
\newtheorem{Th}{Theorem}
\newtheorem{St}{Statement}
\newtheorem{Pf}{Proof}
\newtheorem{Rm}{Remark}
\newtheorem{Ex}{Example}

\newcommand{\setcharmvcn}{M}
\newcommand{\setcharmt}{T}

\newcommand{\setsymbol}[3]{\mathcal{#1}_{#2,#3}}

\newcommand{\setmvcn}[2]{\setsymbol{\setcharmvcn}{#1}{#2}}
\newcommand{\setmt}[2]{\setsymbol{\setcharmt}{#1}{#2}}

\newcommand{\seta}{\mathcal{A}}
\newcommand{\setn}{\mathcal{N}}

\newcommand{\flatten}{\operatorname{Fl}}
\newcommand{\select}{\operatorname{Sel}}
\newcommand{\deref}{\operatorname{Get}}
\newcommand{\proj}[2]{\operatorname{pr}^{#1}_{#2}}

\title{Compound names with multiple values: formalisation, properties and implementation}
\author{Vadim Vinnik}
\date{2016}

\begin{document}

\maketitle

\begin{abstract}
Naming is one of the most fundamental phenomena for programming.  In most
cases, a name is considered to be atomic and to have a unique value.  This
paper describes a kind of naming with both these principles negated: names form
a monoid under concatenation, and each name can be associated with multiple
values.  Two different but equivalent formalisations are defined, their
isomorphism is shown.  Counterparts of set-theoretical union, intersection and
cartesian product operations are described together with their properties.  A
type implementing this kind of naming is designed in Haskell, it fits into
functor, applicative functor and monad classes.
\end{abstract}

\tableofcontents

\section{Introduction}

%todo:
Why naming is so important. Why its formalisation is needed.

Suppose there is a given set~$D$ whose elements are called \emph{values}, or
\emph{denotata}, and a set~$V$ of objects called \emph{names}.

A quite natural formalisation of \emph{naming} as a relation between names and
their values is the following
\begin{Df}\label{df:naming-set}
A \emph{naming set} is a partial mapping $s: V\to D$.
\end{Df}

In other words, a naming set is an object of the form
\[
  s = \{ (v_1, d_1), (v_2, d_2), \ldots, \} ,
\]
where $v_i\in V$, $d_i\in D$, and all~$v_i$ are pairwise distinct. The
latter requirement formalizes \emph{unambiguity}, or \emph{univaluedness}: a
name cannot have different values in a given context.

\begin{Ex}\label{ex:naming-set}
A naming set $s = \{ (a, 1), (t, 7), (w, 1) \}$ represents a context where
the name~$a$ has a value~1, the name~$b$ refers to a value~7 and the name~$w$
denotes~1, no other names have values.
\end{Ex}

Naming mappings defined as above are widely used in theoretical computer
science for syntactical as well as semantical tasks.
%todo: references
Maps, as direct
implementations of naming sets, are included into standard libraries of various
programming languages and platforms and widely used in practice.
%todo: references

At the topmost abstraction level, a naming set represents a ``plain'' relation
where names and values are atomic in the sense that their internal structures
and any non-trivial properties are hidden as irrelevant.  In fact, the only
special property taken into account by the definition above is equatability of
names: for any two names it should be possible to decide whether they are
identical.  Although def.~\ref{df:naming-set} does not \emph{require} atomicity
of names and absence of non-trivial properties, it does not \emph{state} any of
them.

Introducing various properties of names and/or denotata, one can obtain a
number of interesting and useful specialised formalisations of naming for
theoretical purposes as well as implementable data structures suitable for
practical tasks. This article describes a kind of naming with
two important differences from the definition~\ref{df:naming-set}:
\begin{itemize}
\item multivaluedness: any name can be related to zero or more values;
\item compoundness of names: names form a monoid, i.e. compound names could
be concatenated from simpler ones.
\end{itemize}

\subsection*{Notation}

If~$X$ is a set, let~$X^\ast$ denote a set of all sequences of its elements
(also known as \emph{chains}), and~$2^X$ be a set of all its subsets.
If~$a,b\in X^\ast$ are two chains, their concatenation will be denoted simply
as~$ab$. Let~$\varepsilon$ stand for the empty chain.
Let $\proj{n}{k}$ be a function that maps an $n$-tuple to its $k$-th component.

A set of lower-case Latin letters (the alphabet) is denoted as~$\seta$,
and~$\setn$ will denote a set of natural numbers~-- these two sets will be
used in examples.


\section{Relation-based definition and basic properties}

Let~$V$ be a given set of objects called \emph{atomic names}. Elements
of~$V^\ast$ are called \emph{compound names}. Let us omit the words ``atomic''
and ``compound'' if it does not lead to confusion.

\begin{Df}\label{df:mvcn}
A \emph{$(V,D)$-multi-valued compound-naming set ($(V,D)$-MVCNset)} is a binary
relation
\[
  p \subseteq V^\ast \times D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``MVCNset''. A set of $(V,D)$-MVCNsets will be
denoted~$\setmvcn{V}{D}$.
\end{Df}

\begin{Ex}\label{ex:mvcn}
The following is a $(\seta, \setn)$-MVCNset:
\[
  p = \{
    (\varepsilon, 0),
    (\varepsilon, 1),
    (a,           2),
    (a,           3),
    (a,           4),
    (aa,          5),
    (ab,          6),
    (b,           7),
    (baaa,        8)
  \} .
\]
Here the empty name has two values (0 and~1), name~$a$ has three (2, 3 and~4),
comound names~$aa$ and~$ab$ have each a single value (5 and~6, respectively),
name~$b$ has a value~7 and, finally, a name~$baaa$ has one value~8. All other
names from~$\seta$ have no values.
\end{Ex}

Note that, in contrast with naming sets, no special conditions are imposed
on an MVCNset~--- it is just an arbitrary set of name-value pairs.
Therefore, $\setmvcn{V}{D}$ is closed against set-theoretical union
and intersection.
\begin{St}\label{st:mvcn-setop}
If~$p$ and~$q$ are $(V,D)$-MVCNsets, so are~$p\cup q$ and~$p\cap q$.
\end{St}

When it is important to emphasise that union and intersection are operations
on MVCNsets rather than on general case of sets, we will
write~$\cup_\setcharmvcn$ and~$\cap_\setcharmvcn$.

One of the fundamental operations on (univalued) naming sets is retrieving
an only (if any) value~$d$ associated with the name~$v$ in a certain naming
set~$s$.  Depending on the goals and abstraction level of a particular
context, it could be regarded either as~$s(v)=d$, i.e. applying a function~$s$
to an argument~$v$, or as an operation whose arguments are the naming set and
the name, i.e.~$\deref(s, v)=d$. Its counterpart in MVCNset world that
retrieves all values of a name, no matter how many, obviously cannot be denoted
using the first style because MVCNsets, as general binary relations, need not
to be functional.

\begin{Df}\label{df:mvcn-dereferencing}
\emph{Dereferencing} is an operation~$\deref_\setcharmvcn$ (or, whenever
possible, omiting the subscript simply~$\deref$), such that for
a $(V,D)$-MVCNset~$p$ and a name~$v\in V^\ast$,
\[
  \deref_\setcharmvcn(p, v) = \{ d \mid (v, d) \in p \} .
\]
\end{Df}

Unlike the univalued case, here~$\deref$ is a total operation: even if a
name~$v$ does not have any associated value in an MVCNset~$p$, dereferencing
just yields an empty set of values.

\begin{Ex}\label{ex:mvcn-dereferencing}
Consider an MVCNset~$p$ from ex.~\ref{ex:mvcn}. Then
\begin{eqnarray*}
  \deref(p, \varepsilon) & = & \{ 0, 1 \}, \\
  \deref(p, baaa)        & = & \{ 8 \}, \\
  \deref(p, cdcd)        & = & \varnothing .
\end{eqnarray*}

\end{Ex}

It folllows immediately from the definition that dereferencing distributes
over set-theoretical operations.
\begin{St}\label{st:mvcn-deref-distributivity}
Let~$\odot$ stand for either~$\cup$ or~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-MVCNsets. Then
\[
  \deref(p\odot q, v) = \deref(p, v) \odot \deref(q, v) ,
\]
for every~$v\in V^\ast$.
\end{St}

Let us introduce special terms and symbols for the two extreme cases of
MVCNsets, namely:
\begin{Df}\label{df:mvcn-extremes}
MVCNsets $\bot_\setcharmvcn$ called \emph{empty} and $\top_\setcharmvcn$ called
\emph{full} are defined by
\begin{eqnarray*}
  \bot_\setcharmvcn &  = &  \varnothing ; \\
  \top_\setcharmvcn &  = &  V^\ast \times D .
\end{eqnarray*}
Further, we'll omit the subscript when it does not lead to confusion.
\end{Df}

In other words, each name in the empty MVCNset has no value whereas in the
full MVCNset every name has all possible values. Let us formalize this
elementary fact for the further use.
\begin{St}\label{st:mvcn-extreme-deref}
For any~$v\in V^\ast$,
\begin{eqnarray*}
  \deref(\bot, v) & = & \varnothing, \\
  \deref(\top, v) & = & D .
\end{eqnarray*}
\end{St}

The next property is also just a trivial consequence of the definition:~$\bot$
and~$\top$ are neutral elements of~$\cup$ and~$\cap$, respectively.
\begin{St}\label{st:mvcn-neutrals}
For any MVCNset~$p$,
\begin{eqnarray*}
  \bot \cup p & = & p, \\
  \top \cap p & = & p .
\end{eqnarray*}
\end{St}

Note that a compound name~$v$ in a MVCNset~$p$ not only is a reference to
multiple values but also is a common prefix for a ``bunch'' of names starting
with~$v$. In this sence,~$v$ is a name for an entire sub-object of~$p$ that is
defined as follows.
\begin{Df}\label{df:mvcn-select}
Let~$p\in\setmvcn{V}{D}$, $v\in V^\ast$, then \emph{selection} from~$p$
under~$v$ is
\[
  \select_\setcharmvcn(p,v) = \{ (w, d) \mid (vw, d)\in p \} .
\]
As always, the subscript will be omited if possible.
\end{Df}

\begin{Ex}\label{ex:mvcn-select}
Let~$p$ be an MVCNset from ex.~\ref{ex:mvcn}, then
\begin{eqnarray*}
  \select(p, a) & = & \{
    (\varepsilon, 2),
    (\varepsilon, 3),
    (\varepsilon, 4),
    (a,           5),
    (b,           6)
  \} , \\
  \select(p, b) & = & \{
    (\varepsilon, 7),
    (aaa,         8)
  \} , \\
  \select(p, cdcd) & = & \bot .
\end{eqnarray*}
\end{Ex}

\begin{St}\label{st:mvcn-selection-properties}
For any~$p,q\in\setmvcn{V}{D}$, $u, v\in V^\ast$, $\odot\in\{\cup, \cap\}$,
\begin{eqnarray*}
  & \select(\bot,u) = \bot, \\
  & \select(\top,u) = \top, \\
  & \select(p,\varepsilon) = p, \\
  & \select(p,uv) = \select(\select(p,u), v), \\
  & \select(p\odot q, u) = \select(p,u)\odot \select(q,u).
\end{eqnarray*}
\end{St}
In other words,
\begin{itemize}
\item $\select$~preserves empty and full MVCNset;
\item selection under an empty name is an identity over MVCNsets;
\item selection under a compound name can be performed by parts;
\item selection is distributive over union and intersection.
\end{itemize}

It is interesting to note that there is another formalization of the
multivalued naming that is, however, equivalent to the above definitions.  It
is described in the next section.


\section{Trie-based definition}

Take a closer look at the MVCNset~$p$ from ex.~\ref{ex:mvcn}.
Recall the
idea underlying selection operation: that any name~$u$ identifies a bunch of
names that have~$u$ as its common prefix. Except this, take into account that
the empty name~$\varepsilon$ is a common prefix for all names.

The name~$\varepsilon$, the simplest name ever, refers in~$p$ to a set of
values~$\{0,1\}$. Name~$a=\varepsilon a$ is an extension of~$\varepsilon$ by
one atomic name and refers to values~$\{2,3,4\}$. In its turn, name~$a$ can
be extended by one atomic name to~$aa$, $ab$, \ldots, $az$, from which only the
former two are of intrest because their sets of values are non-empty.
Now return to the empty name and compose another its continuation, namely~$b$.
This name is a prefix for~$ba$ that, in its turn, can be extended to~$baa$ and
then to~$baaa$.

All this gives a hierarchical view of~$V^\ast$ where
\begin{itemize}
\item the highest member of the hierarchy is the empty name;
\item appending an atomic component to a name moves one level deeper;
\item having a common prefix means having a common ancestor.
\end{itemize}
The hierarchical representation of the MVCNset~$p$ is shown on the
fig.~\ref{fig:trie}.

\begin{figure}[ht]
\begin{center}
\begin{minipage}{17em}
\dirtree{%
  .1 $\varepsilon$\DTcomment{$\{0, 1\}$} .
    .2 $a$\DTcomment{$\{2, 3, 4\}$} .
      .3 $a$\DTcomment{$\{5\}$} .
      .3 $b$\DTcomment{$\{6\}$} .
    .2 $b$\DTcomment{$\{7\}$} .
      .3 $a$\DTcomment{$\varnothing$} .
        .4 $a$\DTcomment{$\varnothing$} .
          .5 $a$\DTcomment{$\{8\}$} .
}
\end{minipage}
\end{center}
\caption{A multitrie corresponding to the MVCNset~$p$}\label{fig:trie}
\end{figure}

To grasp this informal consideration in a definition, it would be convenient to
assume that every node in the hierarchy has \emph{all} possible children (i.e.
that the hieraarchy includes all names from~$V^\ast$ regardless of whether they
have values): otherwise we needed a special treatment for missing names in
every subsequent definition or statement. This leads to the following

\begin{Df}\label{df:mt}
A class of \emph{$(V,D)$-multitries} (or simply \emph{multitries} when~$V$
and~$D$ are known from the context or irrelevant):
\[
  \setmt{V}{D} = 2^D \times (V \to \setmt{V}{D}) .
\]
\end{Df}

In other words, a $(V,D)$-multitrie is a pair $p = (s, f)$ where~$s\subseteq D$
is a set of values and $f: V \to \setmt{V}{D}$ is a function that maps any
atomic name to some $(V,D)$-multitrie. Note that this recursive definition does
not have any basic case: every multitrie contains sub-multitries (that, in
their turn, have the same structure) under all atomic names.

The definition means that a $(V,D)$-multitrie is a \emph{trie} also known as
a prefx tree, where every node stores a subset of~$D$ as a value, and has
children labelled with all atomic names from~$V$. This means that such a trie
is infinite and has no leaf nodes.
%todo: reference about trie
Depicting multitries graphically, as on fig.~\ref{fig:trie}, we will however
only draw nodes of interest assuning that all other nodes have empty sets of
values.

Extreme multitries have the following recurrent definitions.
\begin{Df}\label{df:mt-extreme}
\emph{Empty} and \emph{full} $(V,D)$-multitries:
\begin{eqnarray*}
  \bot_\setcharmt & = &
      ( \varnothing, \{ v \mapsto \bot_\setcharmt \mid v\in V \} ) , \\
  \top_\setcharmt & = &
      ( D,           \{ v \mapsto \top_\setcharmt \mid v\in V \} ) .
\end{eqnarray*}
Subscripts will be further omited whenever possible.
\end{Df}
In other words, empty (full) multitrie is a multitrie that has an empty
(full) set of values and whose children under all atomic names are, in their
turn, empty (full) multitries.

\begin{Df}\label{df:mt-select}
\emph{Selection} operation. Let $p=(s,f) \in \setmt{V}{D}$, $u\in V$,
$v\in V^\ast$, then
\begin{eqnarray*}
  \select_\setcharmt(p, \varepsilon) & = & p , \\
  \select_\setcharmt(p, u v) & = & \select_\setcharmt(f(u), v) .
\end{eqnarray*}
Subscripts will be omited if possible.
\end{Df}

In other words, selection operation finds a node pointed to by the
compound name as a path in the trie.
Selection is the basic operation on multitries.

\begin{Ex}\label{ex:mt-select}
Consider a multitrie~$p$ depicted on fig.~\ref{fig:trie}. Selection under a
name~$a$ results in a multitrie~$\select(p,a)$ shown on
fig.~\ref{fig:mt-select}.
\end{Ex}

\begin{figure}[ht]
\begin{center}
\begin{minipage}{17em}
\dirtree{%
  .1 $\varepsilon$\DTcomment{$\{2, 3, 4\}$} .
    .2 $a$\DTcomment{$\{5\}$} .
    .2 $b$\DTcomment{$\{6\}$} .
}
\end{minipage}
\end{center}
\caption{Selection of a multitrie}\label{fig:mt-select}
\end{figure}

\begin{Df}\label{df:mt-deref}
Given a $(V,D)$-multitrie~$p$ and a name~$v\in V^\ast$, \emph{dereferencing}
of~$v$ in~$p$ is
\[
  \deref_\setcharmt(p, v) = \proj{2}{1}(\select(p, v)) .
\]
As always, we'll not write the subscript if it is obvious from the context.
\end{Df}

In other words, if $\select(p,v) = (s,f)$, then $\deref(p, v) = s$. To
dereference a name in a multitrie, one needs to follow the compound name
as a path to a node in the trie and then take the value stored in that node.

Union and intersection could be defined for multitries.
\begin{Df}\label{df:mt-setop}
Let $\odot \in \{ \cup, \cap \}$, $p, q \in \setmt{V}{D}$,
$p = (s,f)$, $q = (t, g)$. Then
\[
  p \odot_\setcharmt  q = (s \odot t, \{ v \mapsto f(v) \odot_\setcharmt  g(v) \mid v \in V \}) .
\]
Note that subscripts in this definition help to distinguish between
set-theoretical operations on sets of values and corresponding operations
on multitries.
\end{Df}

In other words, to build $r = p \cup q$, one needs to build the union of the
value sets contained in both operands under the same path.
It is easy to see that properties identical to those of MVCNsets
hold for multitries, namely counterparts of
st.~\ref{st:mvcn-deref-distributivity},
\ref{st:mvcn-extreme-deref},
\ref{st:mvcn-neutrals}
and~\ref{st:mvcn-selection-properties}.
Moreover, all properties of MVCNsets and multitries are identical because
of the following.

\begin{St}\label{st:isomorph}
Consider a mapping~$\varphi: \setmvcn{V}{D} \to \setmt{V}{D}$, such that,
for any~$p\in \setmvcn{V}{D}$,
\[
  \varphi(p) = (
    \deref_\setcharmvcn(p, \varepsilon) ,
    \{ u \mapsto \select_\setcharmvcn(p, u) \mid u\in V \}
  ) .
\]
Then~$\varphi$ is a bijection that preserves
extreme elements, union, intersection, dereferencing and selection operations:
\begin{eqnarray*}
  & \varphi(\bot_{\setcharmvcn}) = \bot_{\setcharmt}, \\
  & \varphi(\top_{\setcharmvcn}) = \top_{\setcharmt}, \\
  & \varphi(p \mathbin{\odot_{\setcharmvcn}} q) =
      \varphi(p) \mathbin{\odot_{\setcharmt}} \varphi(q) , \\
  & \deref_{\setcharmvcn}(p, v) =
      \deref_{\setcharmt}(\varphi(p), v) , \\
  & \varphi(\select_{\setcharmvcn}(p, v)) =
      \select_{\setcharmt}(\varphi(p), v) .
\end{eqnarray*}
\end{St}

In other words, $\varphi$~is an isomorphism from many-sorted algebra of
MVCNsets to an algebra of multitries.
This allows us to switch flexibly between MVCNset and multitrie
languages when describing further notions, choosing the most
appropriate form in each particular case.


\section{Cartesian product and flattening}

This section describes two more complicated operations that change structure of
their operands. Before giving a formal definition for a cartesian product of
MVCNsets or multitries, let us informally describe how should an operation
look like to deserve this name.

Let~$p$ and~$q$ be two multitries. Their cartesian product should consist of
values of the form~$(d',d'')$ where $d'$~is a value from~$p$ and $d''$~is taken
from~$q$. But values are contained in multitries not on their own, they are
attached to some names~-- say, $u$~and~$v$, respectively. As the product's
value~$(d',d'')$ is combined from the values taken from operands, the name of
this combined value must be combined from~$u$ and~$v$, and the only combining
operation defined for names is concatenation.

\begin{Df}\label{df:mvcn-cartesian}
Let~$p$ and~$q$ be $(V,D')$- and $(V,D'')$-MVCNsets, respectively. Their
\emph{cartesian product} is a $(V,D'\times D'')$-MVCNset
\[
  p\times q = \{ (uv, (d',d'')) \mid (u,d')\in p, (v,d'')\in q \} .
\]
\end{Df}

\begin{Ex}\label{ex:cartesian}
Consider the following MVCNsets:
\begin{eqnarray*}
  p & = & \{ (\varepsilon, 0), (a, 1), (a, 2) \} , \\
  q & = & \{ (\varepsilon, 3), (\varepsilon, 4), (c, 5) \} .
\end{eqnarray*}
Then their cartesian product is
\begin{eqnarray*}
  p \times q & = &  \{ (\varepsilon, (0, 3)), (\varepsilon, (0, 4)) \} \cup \\
    & \cup & \{ (c, (0, 5)) \} \cup \\
    & \cup & \{ (a, (1, 3)), (a, (1, 4)), (a, (2, 3)), (a, (2, 4)) \} \cup \\
    & \cup & \{ (ac, (1, 5)), (ac, (2, 5)) \} .
\end{eqnarray*}
%TODO: $q \times p$
\end{Ex}

Obviously,~$\times$ distributes over $\cap$ and $\cup$.
\begin{St}\label{st:cartesian-distributivity}
For any $p \in \setmvcn{V}{D'}$ and $q, r \in \setmvcn{V}{D''}$,
\[
  p\times(q\odot r) = (p\times q) \odot (p\times r) .
\]
\end{St}

The main property of this operation is the following.
\begin{St}\label{st:deref-cartesian}
For any $p \in \setmvcn{V}{D'}$ and $q \in \setmvcn{V}{D''}$,
\[
  \deref(p \times q, w) =
      \bigcup_{u,v\in V^\ast: uv = w}
          \deref(p, u)
          \times
          \deref(q, v) .
\]
\end{St}
It means that, since an MVCNset is completely defined by values of all names,
cartesian product can be defined in terms of dereferencing and, therefore,
is preserved by the mapping~$\varphi$ from st.~\ref{st:isomorph}. Also, this
property may be taken as a definition of cartesian product for multitries.

Consider an MVCNset whose values are, in their turn, MVCNsets.
Flattening operation formally defined below turns it into a ``plain'' MVCNset.
\begin{Df}\label{df:flatten}
\emph{Flattening} is an unary operation
$\flatten : \setmvcn{V}{\setmvcn{V}{D}} \to\setmvcn{V}{D}$,
such that, for any $(V,\setmvcn{V}{D})$-MVCNset~$p$, the
corresponding $r=\flatten(p)$ is defined by
\[
  r = \{ (uv, d) \mid (u, t) \in p, (v, d) \in t \} .
\]
\end{Df}

The following property can be used to define flattening for multitries
deriving it from dereferencing operation.
\begin{St}\label{st:deref-flatten}
For any $(V,\setmvcn{V}{D})$-MVCNset~$p$,
\[
  \deref(\flatten(p), w) =
      \bigcup_{u,v\in V^\ast: uv = w}
        \deref(\deref(p, u), v) .
\]
\end{St}

\section{Notes about implementation}

\section{Application}

\end{document}

