%-------------------------------------------------------------------
%
% Author    : Vadim Vinnik
% E-mail    : vadim.vinnik@gmail.com
% Date      : 2015-12-03
% Status    : Draft
% License   : Creative commons
% Keywords  : name, value, map, trie, multi-set, haskell, monad
%
% Summary
% A ``trie of multisets'' is defined as a mathematical concept that
% reflects some aspects of structured data objects in programming;
% Properties thereof are investigated; An implementation in Haskell
% is described.
%
%-------------------------------------------------------------------

\documentclass{article}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{Df}{Definition}
\newtheorem{Th}{Theorem}
\newtheorem{Pf}{Proof}
\newtheorem{Rm}{Remark}

\newcommand{\mtempty}{\bot}
\newcommand{\mtfull}{\top}
\newcommand{\set}[1]{\mathcal{#1}}
\newcommand{\setmt}[2]{\set{M}_{#1,#2}}
\newcommand{\flatten}{\mathrm{Fl}}
\newcommand{\select}{\mathrm{Sel}}
\newcommand{\singleleaf}{\mathrm{Sg}}

\title{Tries of multisets, their properties, applications and implementation}
\author{Vadim Vinnik}
\date{2015}

\begin{document}

\maketitle

\begin{abstract}
A ``trie of multisets'' is defined as a mathematical concept that
reflects some aspects of structured data objects in programming;
Properties thereof are investigated; An implementation in Haskell
is described.
\end{abstract}

\tableofcontents

\section{Introduction}

%todo:
Why naming is so important. Why its formalisation is needed.

Suppose there is a given set~$D$ whose elements are called \emph{values}, or
\emph{denotata}, and a set~$V$ of objects called \emph{names}.

A quite natural formalisation of \emph{naming} as a relation between names and
their values is the following
\begin{Df}
A \emph{naming set} is a partial mapping $s: V\to D$.\qed
\end{Df}

In other words, a naming set is an object of the form
\[
  s = \{ (v_1, d_1), (v_2, d_2), \ldots, \} ,
\]
where $v_i\in V$, $d_i\in D$ and all names~$v_i$ are pairwise distinct. The
latter requirement formalizes \emph{unambiguity}, or \emph{univaluedness}: a
name cannot have different values in a given context.

Naming mappings defined as above are widely used in theoretical computer
science for syntactical as well as semantical tasks. Maps as direct
implementations of naming sets are included into standard libraries of various
languages and platforms and widely used in practice.

At the topmost abstraction level, a naming set represents a plain naming
relation where names and values are atomic in the sense that their internal
structures and any non-trivial properties are hidden as being irrelevant. In
fact, the only special property taken into account by the definition above is
equatability of names: for any two names it should be possible to decide
whether they are identical.

Introducing various properties of names and/or denotata, one can obtain a
number of interesting and useful specialised formalisations of naming for
theoretical purposes as well as data structures implementing them.
This article describes a case where
\begin{itemize}
\item names form a monoid, i.e. compound names can be concatenated from
simpler ones;
\item values are sets (replaced by sequences in the implementation).
\end{itemize}

\section{Definition and basic properties}

If~$X$ is a set, let~$X^\ast$ denote a set of all sequences of its elements
(also known as \emph{chains}),
and~$2^X$ be a set of all its subsets. If~$a,b\in X^\ast$ are two chains,
their concatenation will be denoted simply as~$ab$. Let~$\varepsilon$ stand for
the empty chain.

Let~$V$ be a given set of objects called \emph{atomic names}. Elements
of~$V^\ast$ are called \emph{compound names}. Let us omit the words ``atomic''
and ``compound'' if it does not lead to confusion.

\begin{Df}
An \emph{$(V,D)$-multitrie} is a total mapping
\[
  p : V^\ast \to 2^D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``multitrie''. A set of $(V,D)$-multitries will be
denoted~$\setmt{V}{D}$.\qed
\end{Df}

In other words, a multitrie could be regarded as a naming set whose names are
compound names and denotata are sets of objects from~$D$. The only important
detail here is totality of~$p$: every compound name has some value.

\begin{Df}
A multitrie~$p$ is called \emph{empty} (\emph{full}) and denoted~$\mtempty$
(respectively,~$\mtfull$) if $p(v)=\varnothing$ (resp., $p(v)=D$) for any~$v\in
N^\ast$.

Let~$v$ be some compound name and~$A$ be some set of values, $v\in V^\ast$,
$A\subseteq D$.  Then~$p = \singleleaf(v,A)$ is such a multitrie that~$p(v) =
A$ and~$p(u) = \varnothing$ for any $u\in V^\ast$, $u\neq v$.

A multitrie~$p$ is said to be \emph{name-finite} if the set
\[
  Q_p = \{ v \in V^\ast \mid p(v) \neq \varnothing \} .
\]
(i.e. the set of all ``occupird'' names) is finite.\qed
\end{Df}

Note that a compound name~$v$ in a multitrie~$p$ not only points to a set
value but also to a ``bunch'' of names of the form~$vw$, i.e. names having~$u$
as their common prefix. This gives us
the most important operation on multItries, selection by a compound name,
formally defined below. Essentially, if~$p$ is a multitrie and~$v$ is a name,
$\select(p,v)$ is a multitrie whose names are suffixes of~$v$ in~$p$, with
respective values.

\begin{Df}\label{def:select}
Let~$p\in\setmt{V}{D}$, $v\in V^\ast$, then
\[
  \select(p,v) = \{ (w, p(vw)) \mid w\in V^\ast \} .\qedhere
\]
\end{Df}

Obviously, for any multi-trie~$p$ and compound names~$u,v$:
\begin{eqnarray*}
  & \select(p,\varepsilon) = p ,\\
  & \select(p,uv) = \select(\select(p,u), v) .
\end{eqnarray*}

Operations similar to those of set theory can be naturally defined for multitries.

\begin{Df}\label{def:union-intersection}
Let~$\odot$ stand for any of~$\cup$ and~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-multitries. Then their \emph{union} and \emph{intersection} are
$(V,D)$-multitries, such that
\[
  (p\odot q)(v) = p(v) \odot q(v) ,
\]
for every~$v\in V^\ast$.\qed
\end{Df}

Obviously, empty and full multitries are neutral elements of union and intersection,
respectively. These operations are commutative, associative and idempotent.
Moreover, these operations are distributive against selection:
\[
  \select(p\odot q, v) = \select(p, v) \odot \select(q, v) .
\]

\begin{Df}\label{def:cartesian}
Let~$p$ and~$q$ be $(V,D')$- and $(V,D'')$-multitries, respectively. Their
\emph{cartesian product} $p\times q = r$ is a $(V,D'\times D'')$-multitrie
such that
\[
  r(w) = \bigcup_{u,v\in V^\ast: uv = w} p(u) \times q(v)
\]
for any~$w\in V^\ast$.\qed
\end{Df}

Consider a multitrie whose values are, in their turn, multitries.
Flattening operation formally defined below turns it into a ``plain'' multitrie.
\begin{Df}\label{def:flatten}
\emph{Flattening} is an unary operation $\flatten : \setmt{V}{\setmt{V}{D}}
\to\setmt{V}{D}$, such that, for any $(V,\setmt{V}{D})$-multitrie~$p$, the
corresponding $r=\flatten(p)$ is defined by
\[
  r(w) = \bigcup_{u,v\in V^\ast: uv = w} p(u)(v)
\]
for any name~$w\in V^\ast$.\qed
\end{Df}

It is easy to see that the above definitions are equivalent to the following:
\begin{eqnarray}
  \label{eq:alt-cartesian}
  p\times q =
    \bigcup_{u,v\in V^\ast} \singleleaf(uv, p(u) \times q(v)) ,\\
  \label{eq:alt-flatten}
  \flatten(p) =
    \bigcup_{u,v\in V^\ast} \singleleaf(uv, p(u)(v)) .
\end{eqnarray}
(note that~$\cup$ in the definitions~\ref{def:cartesian} and~\ref{def:flatten}
means a set-theoretical union whereas in~(\ref{eq:alt-cartesian})
and~(\ref{eq:alt-flatten}) it means union of multitries, see
def.~\ref{def:union-intersection}).

\section{Alternative approach}

The above definition is abstract in the sense that it only describes how do
multitries look like from outside~-- namely, as a correspondence between
compound names and their values.

\section{Notes about implementation}

\section{Application}

\end{document}

