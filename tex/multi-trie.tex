%-------------------------------------------------------------------
%
% Author    : Vadim Vinnik
% E-mail    : vadim.vinnik@gmail.com
% Date      : 2015-12-03
% Status    : Draft
% License   : Creative commons
% Keywords  : name, value, map, trie, multi-set, haskell, monad
%
% Summary
% A ``trie of multisets'' is defined as a mathematical concept that
% reflects some aspects of structured data objects in programming;
% Properties thereof are investigated; An implementation in Haskell
% is described.
%
%-------------------------------------------------------------------

\documentclass{article}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{Df}{Definition}
\newtheorem{Th}{Theorem}
\newtheorem{St}{Statement}
\newtheorem{Pf}{Proof}
\newtheorem{Rm}{Remark}

\newcommand{\setcharmvcn}{M}
\newcommand{\setcharmt}{T}

\newcommand{\setsymbol}[3]{\mathcal{#1}_{#2,#3}}

\newcommand{\setmvcn}[2]{\setsymbol{\setcharmvcn}{#1}{#2}}
\newcommand{\setmt}[2]{\setsymbol{\setcharmt}{#1}{#2}}

\newcommand{\flatten}{\mathrm{Fl}}
\newcommand{\select}{\mathrm{Sel}}
\newcommand{\singleleaf}{\mathrm{Sg}}
\newcommand{\proj}[1]{\mathrm{pr}_{#1}}

\newcommand{\derefsymbol}{\mathrm{Get}}
\newcommand{\deref}[2]{\derefsymbol(#1, #2)}

\title{Tries of multisets, their properties, applications and implementation}
\author{Vadim Vinnik}
\date{2015}

\begin{document}

\maketitle

\begin{abstract}
A ``trie of multisets'' is defined as a mathematical concept that
reflects some aspects of structured data objects in programming;
Properties thereof are investigated; An implementation in Haskell
is described.
\end{abstract}

\tableofcontents

\section{Introduction}

%todo:
Why naming is so important. Why its formalisation is needed.

Suppose there is a given set~$D$ whose elements are called \emph{values}, or
\emph{denotata}, and a set~$V$ of objects called \emph{names}.

A quite natural formalisation of \emph{naming} as a relation between names and
their values is the following
\begin{Df}\label{df:naming-set}
A \emph{naming set} is a partial mapping $s: V\to D$.
\end{Df}

In other words, a naming set is an object of the form
\[
  s = \{ (v_1, d_1), (v_2, d_2), \ldots, \} ,
\]
where $v_i\in V$, $d_i\in D$ and all~$v_i$ are pairwise distinct. The
latter requirement formalizes \emph{unambiguity}, or \emph{univaluedness}: a
name cannot have different values in a given context.

Naming mappings defined as above are widely used in theoretical computer
science for syntactical as well as semantical tasks.
%todo: references
Maps as direct
implementations of naming sets are included into standard libraries of various
programming languages and platforms and widely used in practice.
%todo: references

At the topmost abstraction level, a naming set represents a ``plain''
relation where names and values are atomic in the sense that their internal
structures and any non-trivial properties are hidden as irrelevant. In
fact, the only special property taken into account by the definition above is
equatability of names: for any two names it should be possible to decide
whether they are identical.

Introducing various properties of names and/or denotata, one can obtain a
number of interesting and useful specialised formalisations of naming for
theoretical purposes as well as implementable data structures suitable for
practical tasks. This article describes a kind of naming with
two differences from the definition~\ref{df:naming-set}:
\begin{itemize}
\item multivaluedness: any name can be related to zero or more values;
\item compoundness of names: names form a monoid i.e. compound names could
be concatenated from simpler ones.
\end{itemize}


\section{Relation-based definition and basic properties}

If~$X$ is a set, let~$X^\ast$ denote a set of all sequences of its elements
(also known as \emph{chains}), and~$2^X$ be a set of all its subsets.
If~$a,b\in X^\ast$ are two chains, their concatenation will be denoted simply
as~$ab$. Let~$\varepsilon$ stand for the empty chain.

Let~$V$ be a given set of objects called \emph{atomic names}. Elements
of~$V^\ast$ are called \emph{compound names}. Let us omit the words ``atomic''
and ``compound'' if it does not lead to confusion.

\begin{Df}\label{df:mvcn}
A \emph{$(V,D)$-multi-valued compound-naming set (MVCNset)} is a binary
relation
\[
  p \subseteq V^\ast \times D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``MVCNset''. A set of $(V,D)$-MVCNsets will be
denoted~$\setmvcn{V}{D}$.
\end{Df}

Note that, in contrast with naming sets, no special conditions are imposed
on an MVCNset~--- it is just an arbitrary set of name-vale pairs.
Therefore, $\setmvcn{V}{D}$ is closed against set-theoretical union
and intersection:
\begin{St}\label{st:mvcn-setop}
If~$p$ and~$q$ are $(V,D)$-MVCNsets, so are~$p\cup q$ and~$p\cap q$.
\end{St}

One of the fundamental operations on (univalued) naming sets is that retrieving
an only (if any) value~$d$ associated with the name~$v$ in a certain naming
set~$s$.  Depending on the goals and abstraction level of any particular
context, it could be regarded either as~$s(v)=d$, i.e. applying a function~$s$
to an argument~$v$, or as an operation whose arguments are the naming set and
the name, i.e.~$\deref{s}{v}=d$. Its counterpart in MVCNset world that
retrieves all values of a name, no matter how many, obviously cannot be denoted
using the first style because MVCNsets are general binary relations, not
functional ones.

\begin{Df}\label{df:mvcn-dereferencing}
\emph{Dereferencing} is an operation, such that for
a $(V,D)$-MVCNset~$p$ and a name~$v\in V^\ast$,
\[
  \deref{p}{v} = \{ d \mid (v, d) \in p \} .
\]
\end{Df}

Unlike the univalued case, here~$\derefsymbol$ is a total operation: even if a
name~$v$ does not have any associated value in an MVCNset~$p$, dereferencing
just yields an empty list of values.  Dereferencing distributes over
set-theoretical operations:
\begin{St}\label{st:mvcn-deref-distributivity}
Let~$\odot$ stand for either~$\cup$ or~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-MVCNsets. Then
\[
  \deref{p\odot q}{v} = \deref{p}{v} \odot \deref{q}{v} ,
\]
for every~$v\in V^\ast$.
\end{St}

Let us introduce special terms and symbols for the two extreme cases of
MVCNsets, namely:
\begin{Df}\label{df:mvcn-extremes}
MVCNsets $\bot$ called \emph{empty} and $\top$ called \emph{full} are defined by
\begin{eqnarray*}
  \bot &  = &  \varnothing ; \\
  \top &  = &  V^\ast \times D .
\end{eqnarray*}
\end{Df}

\begin{St}\label{st:mvcn-extreme-deref}
For any~$v\in V^\ast$,
\begin{eqnarray*}
  \deref{\bot}{v} & = & \varnothing, \\
  \deref{\top}{v} & = & D .
\end{eqnarray*}
\end{St}

It is easy to see that~$\bot$ and~$\top$ are neutral elements
of~$\cup$ and~$\cap$, respectively:
\begin{St}\label{st:mvcn-neutrals}
For any MVCNset~$p$,
\begin{eqnarray*}
  \bot \cup p & = & p, \\
  \top \cap p & = & p .
\end{eqnarray*}
\end{St}

Note that a compound name~$v$ in a MVCNset~$p$ not only is a reference to
multiple values but also is a common prefix for a ``bunch'' of names starting
with~$v$. In this sence,~$v$ is a name for a sub-object of~$p$ that is
defined as follows
\begin{Df}\label{df:mvcn-select}
Let~$p\in\setmvcn{V}{D}$, $v\in V^\ast$, then \emph{selection} from~$p$
under~$v$ is
\[
  \select(p,v) = \{ (w, d) \mid (vw, d)\in p \} .
\]
\end{Df}

The followig properties of selection are obvious:
\begin{St}\label{st:mvcn-selection-properties}
For any~$p,q\in\setmvcn{V}{D}$, $u, v\in V^\ast$, $\odot\in\{\cup, \cap\}$,
\begin{eqnarray*}
  & \select(\bot,u) = \bot, \\
  & \select(\top,u) = \top, \\
  & \select(p,\varepsilon) = p, \\
  & \select(p,uv) = \select(\select(p,u), v), \\
  & \select(p\odot q, u) = \select(p,u)\odot \select(q,u).
\end{eqnarray*}
\end{St}

It is interesting to note that there is another formalization of the
multivalued naming that is, however, equivalent to the above definitions.  It
is described in the next section.


\section{Trie-based definition}

\begin{Df}\label{df:mt}
A class of \emph{$(V,D)$-multitries} (or simply \emph{multitries} when~$V$
and~$D$ are known from the context or irrelevant):
\[
  \setmt{V}{D} = 2^D \times (V \to \setmt{V}{D}) .
\]
\end{Df}

In other words, a $(V,D)$-multitrie is a pair $p = (s, f)$ where~$s\subseteq D$
is a set of values and $f: V \to \setmt{V}{D}$ is a function that maps any
atomic name to some $(V,D)$-multitrie. Note that this recursive definition does
not have any basic case: every multitrie contains named sub-multitries that, in
their turn, have the same structure.

The definition means that a $(V,D)$-multitrie is a \emph{trie} also known as
a prefx tree, where every node stores a subset of~$D$ as a value, and has
children labelled with all atomic names from~$V$. This means that such a trie
is infinite and has no leaf nodes.
%todo: reference about trie

Extreme multitries have the following recurrent definitions.
\begin{Df}\label{df:mt-extreme}
\emph{Empty} and \emph{full} $(V,D)$-multitries:
\begin{eqnarray*}
  \bot & = & ( \varnothing, \{ v \mapsto \bot \mid v\in V \} ) , \\
  \top & = & ( D,           \{ v \mapsto \top \mid v\in V \} ) .
\end{eqnarray*}
\end{Df}
In other words, empty (full) multitrie is a multitrie that has an empty
(full) set of values and whose children under all atomic names are, in their
turn, empty (full) multitries.

The following is the basic operation on multitries.
\begin{Df}\label{df:mt-select}
\emph{Selection} operation. Let $p=(s,f) \in \setmt{V}{D}$, $u\in V$,
$v\in V^\ast$, then
\begin{eqnarray*}
  \select(p, \varepsilon) & = & p , \\
  \select(p, u v) & = & \select(f(u), v) .
\end{eqnarray*}
\end{Df}

In other words, selection operation finds a node pointed to by the
compound name as a path in the trie.

Let $\proj{k}$ be a function that maps a tuple to its $k$-th component.
Then dereferencing could be defined as follows:
\begin{Df}\label{df:mt-deref}
Given a $(V,D)$-multitrie~$p$ and a name~$v\in V^\ast$, \emph{dereferencing}
of~$v$ in~$p$ is
\[
  \deref{p}{v} = \proj{1}(\select(p, v)) .
\]
\end{Df}

In other words, if $\select(p,v) = (s,f)$, then $\deref{p}{v} = s$. To
dereference a name in a multitrie, one needs to follow the compound name
as a path to a node in the trie and then take the value stored in that node.

Union and intersection could be defined for multitries.
\begin{Df}\label{df:mt-setop}
Let $\odot \in \{ \cup, \cap \}$, $p, q \in \setmt{V}{D}$,
$p = (s,f)$, $q = (t, g)$. Then
\[
  p \odot q = (s \odot t, \{ v \mapsto f(v) \odot g(v) \mid v \in V \}) .
\]
\end{Df}

It is easy to see that properties identical to those of MVCNsets
hold for multitries, namely counterparts of
st.~\ref{st:mvcn-deref-distributivity},
\ref{st:mvcn-extreme-deref},
\ref{st:mvcn-neutrals}
and~\ref{st:mvcn-selection-properties}.

Moreover, all properties of MVCNsets and multitries are identical, and these
two kinds of objects should be regarded as essentially the same thing because
of the following.

\begin{St}\label{st:isomorph}
There is a bijection~$\varphi: \setmvcn{V}{D} \to \setmt{V}{D}$ that preserves
union, intersection, dereferencing and selection operations:
\begin{eqnarray*}
  & \varphi(p \mathbin{\odot_{\setcharmvcn}} q) =
      \varphi(p) \mathbin{\odot_{\setcharmt}} \varphi(q) , \\
  & \derefsymbol_{\setcharmvcn}(p, v) =
      \derefsymbol_{\setcharmt}(\varphi(p), v) , \\
  & \select_{\setcharmvcn}(p, v) =
      \select_{\setcharmt}(\varphi(p), v) .
\end{eqnarray*}
\end{St}

The idea underlying~$\varphi$ is quite obvious whereas technical details of the
proof are not important for our current goal.

This isomorphism allows to switch flexibly between MVCNset and multitrie
languages when describing further notions, choosing every time the most
appropriate form.


\section{Cartesian Product}

\begin{Df}\label{df:mvcn-cartesian}
Let~$p$ and~$q$ be $(V,D')$- and $(V,D'')$-MVCNsets, respectively. Their
\emph{cartesian product} is a $(V,D'\times D'')$-MVCNset
\[
  p\times q = \{ (uv, (d',d'')) \mid (u,d')\in p, (v,d'')\in q \} .
\]
\end{Df}

Obviously,~$\times$ is distributive against $\cap$ and $\cup$.
\begin{St}\label{st:cartesian-distributivity}
For any $p \in \setmvcn{V}{D'}$ and $q, r \in \setmvcn{V}{D''}$,
\[
  p\times(q\odot r) = (p\times q) \odot (p\times r) .
\]
\end{St}

The main property of this operation is the following.
\begin{St}\label{st:deref-cartesian}
For any $p \in \setmvcn{V}{D'}$ and $q \in \setmvcn{V}{D''}$,
\[
  \deref{p \times q}{w} =
      \bigcup_{u,v\in V^\ast: uv = w}
          \deref{p}{u}
          \times
          \deref{q}{v} .
\]
\end{St}
It means that, since an MVCNset is completely defined by values of all names,
cartesian product can be defined in terms of dereferencing and, therefore,
is preserved by the mapping~$\varphi$ from st.~\ref{st:isomorph}. Also, this
property may be taken as a definition of cartesian product for multitries.

Consider an MVCNset whose values are, in their turn, MVCNsets.
Flattening operation formally defined below turns it into a ``plain'' MVCNset.
\begin{Df}\label{df:flatten}
\emph{Flattening} is an unary operation
$\flatten : \setmvcn{V}{\setmvcn{V}{D}} \to\setmvcn{V}{D}$,
such that, for any $(V,\setmvcn{V}{D})$-MVCNset~$p$, the
corresponding $r=\flatten(p)$ is defined by
\[
  r = \{ (uv, d) \mid (u, t) \in p, (v, d) \in t \} .
\]
\end{Df}

The following property can be used to define flattening for multitries
deriving it from dereferencing operation.
\begin{St}\label{st:deref-flatten}
For any $(V,\setmvcn{V}{D})$-MVCNset~$p$,
\[
  \deref{\flatten(p)}{w} =
      \bigcup_{u,v\in V^\ast: uv = w}
        \deref{\deref{p}{u}}{v} .
\]
\end{St}

\section{Notes about implementation}

\section{Application}

\end{document}

