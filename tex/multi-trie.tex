%-------------------------------------------------------------------
%
% Author    : Vadim Vinnik
% E-mail    : vadim.vinnik@gmail.com
% Date      : 2015-12-03
% Status    : Draft
% License   : Creative commons
% Keywords  : name, value, map, trie, multi-set, haskell, monad
%
% Summary
% A ``trie of multisets'' is defined as a mathematical concept that
% reflects some aspects of structured data objects in programming;
% Properties thereof are investigated; An implementation in Haskell
% is described.
%
%-------------------------------------------------------------------

\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}

\newtheorem{Df}{Definition}
\newtheorem{Th}{Theorem}
\newtheorem{Pf}{Proof}
\newtheorem{Rm}{Remark}

\newcommand{\mtempty}{\bot}
\newcommand{\mtfull}{\top}
\newcommand{\set}[1]{\mathcal{#1}}
\newcommand{\setmt}[2]{\set{M}_{#1,#2}}
\newcommand{\flatten}{\mathrm{Fl}}
\newcommand{\singleleaf}{\mathrm{Sg}}

\title{Tries of multisets, their properties, applications and implementation}
\author{Vadim Vinnik}
\date{2015}

\begin{document}

\maketitle

\begin{abstract}
A ``trie of multisets'' is defined as a mathematical concept that
reflects some aspects of structured data objects in programming;
Properties thereof are investigated; An implementation in Haskell
is described.
\end{abstract}

\tableofcontents

\section{Introduction}

%todo:
Why naming is so important. Why its formalisation is needed.

Suppose there is a given set~$D$ whose elements are called \emph{values}, or
\emph{denotata}, and a set~$V$ of objects called \emph{names}.

A quite natural formalisation of \emph{naming} as a relation between names and
their values is the following
\begin{Df}
A \emph{naming set} is a partial mapping $s: V\to D$.
\end{Df}

In other words, a naming set is an object of the form
\[
  s = \{ (v_1, d_1), (v_2, d_2), \ldots, \} ,
\]
where $v_i\in V$, $d_i\in D$ and all names~$v_i$ are pairwise distinct. The
latter requirement formalizes \emph{unambiguity}, or \emph{univaluedness}: a
name cannot have different values in a given context.

Naming mappings defined as above are widely used in theoretical computer
science for syntactical as well as semantical tasks. Maps as direct
implementations of naming sets are included into standard libraries of various
languages and platforms and widely used in practice.

At the topmost abstraction level, a naming set represents a plain naming
relation where names and values are atomic in the sense that their internal
structures and any non-trivial properties are hidden as being irrelevant. In
fact, the only special property taken into account by the definition above is
equatability of names: for any two names it should be possible to decide
whether they are identical.

Introducing various properties of names and/or denotata, one can obtain a
number of interesting and useful specialised formalisations of naming for
theoretical purposes as well as data structures implementing them.
This article describes a case where
\begin{itemize}
\item names form a monoid, i.e. compound names can be concatenated from
simpler ones;
\item values are sets (replaced by sequences in the implementation).
\end{itemize}

\section{Definition and basic properties}

If~$X$ is a set, let~$X^\ast$ denote a set of all sequences of its elements,
and~$2^X$ be a set of all its subsets.

Let~$V$ be a given set of objects called \emph{atomic names}. Elements
of~$V^\ast$ are called \emph{compound names}. Let us omit the words ``atomic''
and ``compound'' if it does not lead to confusion.

\begin{Df}
An \emph{$(V,D)$-multitrie} is a total mapping
\[
  p : V^\ast \to 2^D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``multitrie''. A set of $(V,D)$-multitries will be
denoted~$\setmt{V}{D}$.
\end{Df}

In other words, a multitrie could be regarded as a naming set whose names are
compound names and denotata are sets of objects from~$D$. The only important
detail here is totality of~$p$: every compound name has some value.

\begin{Df}
A multitrie~$p$ is called \emph{empty} (\emph{full}) and denoted~$\mtempty$
(respectively,~$\mtfull$) if $p(v)=\varnothing$ (resp., $p(v)=D$) for any~$v\in
N^\ast$.

Let~$v$ be some compound name and~$A$ be some set of values, $v\in V^\ast$,
$A\subseteq D$.  Then~$p = \singleleaf(v,A)$ is such a multitrie that~$p(v) =
A$ and~$p(u) = \varnothing$ for any $u\in V^\ast$, $u\neq v$.

A multitrie~$p$ is said to be \emph{finite} if finite is the set
\[
  Q_p = \{ v \in V^\ast \mid p(v) \neq \varnothing \} .
\]
\end{Df}

A number of operations can be naturally defined for multitries.

\begin{Df}
Let~$\odot$ stand for any of~$\cup$ and~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-multitries. Then their \emph{union} and \emph{intersection} are
$(V,D)$-multitries, such that
\[
  (p\odot q)(v) = p(v) \odot q(v) ,
\]
for every~$v\in V^\ast$.
\end{Df}

Obviously, empty and full multitries are neutral elements of union and intersection,
respectively. These operations are commutative, associative and idempotent.

\begin{Df}
Let~$p$ and~$q$ be $(V,D')$- and $(V,D'')$-multitries, respectively. Their
\emph{cartesian product} $p\times q$ is a $(V,D'\times D'')$-multitrie such that
\[
  (p\times q) % todo
\]
for every~$v\in V^\ast$.
\end{Df}

Consider a multitrie~$p$ whose values are, in their turn, multitries.
Flattening operation, formally defined below, turns it into a multitrie whose
values are those of multitries contained in~$p$.
\begin{Df}
\emph{Flattening} is an unary operation $\flatten : \setmt{V}{\setmt{V}{D}}
\to\setmt{V}{D}$, such that, for any $(V,\setmt{V}{D})$-multitree~$p$ and for any
name~$w\in V^\ast$, $r=\flatten p$ is defined by
\[
  r(w) = \bigcup_{u,v\in V^\ast: uv = w} p(u)(v) .
\]
\end{Df}

In other words, let~$u, v\in V^\ast$ be arbitrary names, and let~$q$ be one of
the values in~$p$ under~$u$, $q \in p(u)$. Now~$r$ is such a multitrie that its
values under a name~$uv$ contain some~$d$ if and only if~$d\in q(v)$. It is
easy to see that the definition above is equivalent to the following:
\[
  r = \bigcup_{u,v\in V^\ast} \singleleaf(uv, p(u)(v))
\]

\section{Alternative approach}

The above definition is abstract in the sense that it only describes how do
multitries look like from outside~-- namely, as a correspondence between
compound names and their values.

\section{Notes about implementation}

\section{Application}

\end{document}
