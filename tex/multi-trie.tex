%-------------------------------------------------------------------
%
% Author    : Vadim Vinnik
% E-mail    : vadim.vinnik@gmail.com
% Date      : 2015-12-03
% Status    : Draft
% License   : Creative commons
% Keywords  : name, value, map, trie, multi-set, haskell, monad
%
% Summary
% A ``trie of multisets'' is defined as a mathematical concept that
% reflects some aspects of structured data objects in programming;
% Properties thereof are investigated; An implementation in Haskell
% is described.
%
%-------------------------------------------------------------------

\documentclass{article}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{Df}{Definition}
\newtheorem{Th}{Theorem}
\newtheorem{St}{Statement}
\newtheorem{Pf}{Proof}
\newtheorem{Rm}{Remark}

\newcommand{\mtempty}{\bot}
\newcommand{\mtfull}{\top}

\newcommand{\setcharmvcn}{C}
\newcommand{\setcharmt}{M}

\newcommand{\setsymbol}[3]{\mathcal{#1}_{#2,#3}}

\newcommand{\setmvcn}[2]{\setsymbol{\setcharmvcn}{#1}{#2}}
\newcommand{\setmt}[2]{\setsymbol{\setcharmt}{#1}{#2}}

\newcommand{\flatten}{\mathrm{Fl}}
\newcommand{\select}{\mathrm{Sel}}
\newcommand{\singleleaf}{\mathrm{Sg}}

\newcommand{\deref}[2]{\mathrm{Get}(#1, #2)}

\title{Tries of multisets, their properties, applications and implementation}
\author{Vadim Vinnik}
\date{2015}

\begin{document}

\maketitle

\begin{abstract}
A ``trie of multisets'' is defined as a mathematical concept that
reflects some aspects of structured data objects in programming;
Properties thereof are investigated; An implementation in Haskell
is described.
\end{abstract}

\tableofcontents

\section{Introduction}

%todo:
Why naming is so important. Why its formalisation is needed.

Suppose there is a given set~$D$ whose elements are called \emph{values}, or
\emph{denotata}, and a set~$V$ of objects called \emph{names}.

A quite natural formalisation of \emph{naming} as a relation between names and
their values is the following
\begin{Df}\label{df:naming-set}
A \emph{naming set} is a partial mapping $s: V\to D$.
\end{Df}

In other words, a naming set is an object of the form
\[
  s = \{ (v_1, d_1), (v_2, d_2), \ldots, \} ,
\]
where $v_i\in V$, $d_i\in D$ and all~$v_i$ are pairwise distinct. The
latter requirement formalizes \emph{unambiguity}, or \emph{univaluedness}: a
name cannot have different values in a given context.

Naming mappings defined as above are widely used in theoretical computer
science for syntactical as well as semantical tasks.
%todo: references
Maps as direct
implementations of naming sets are included into standard libraries of various
programming languages and platforms and widely used in practice.
%todo: references

At the topmost abstraction level, a naming set represents a ``plain''
relation where names and values are atomic in the sense that their internal
structures and any non-trivial properties are hidden as irrelevant. In
fact, the only special property taken into account by the definition above is
equatability of names: for any two names it should be possible to decide
whether they are identical.

Introducing various properties of names and/or denotata, one can obtain a
number of interesting and useful specialised formalisations of naming for
theoretical purposes as well as implementable data structures suitable for
practical tasks. This article describes a kind of naming with
two differences from the definition~\ref{df:naming-set}:
\begin{itemize}
\item multivaluedness: any name can be related to zero or more values;
\item compoundness of names: names form a monoid i.e. compound names could
be concatenated from simpler ones.
\end{itemize}


\section{Abstract definition and basic properties}

If~$X$ is a set, let~$X^\ast$ denote a set of all sequences of its elements
(also known as \emph{chains}), and~$2^X$ be a set of all its subsets.
If~$a,b\in X^\ast$ are two chains, their concatenation will be denoted simply
as~$ab$. Let~$\varepsilon$ stand for the empty chain.

Let~$V$ be a given set of objects called \emph{atomic names}. Elements
of~$V^\ast$ are called \emph{compound names}. Let us omit the words ``atomic''
and ``compound'' if it does not lead to confusion.

\begin{Df}\label{df:mvcn}
A \emph{$(V,D)$-multi-valued compound-naming set (MVCNset)} is a binary
relation
\[
  p \subseteq V^\ast \times D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``MVCNset''. A set of $(V,D)$-MVCNsets will be
denoted~$\setmvcn{V}{D}$.
\end{Df}

Obviously, $\setmvcn{V}{D}$ is closed against set-theoretical union
and intersection:
\begin{St}\label{st:mvcn-closedness}
If~$p$ and~$q$ are $(V,D)$-MVCNsets, so are~$p\cup q$ and~$p\cap q$.
\end{St}

For (univalued) naming sets, to dereference a name means to find its only
value, if any.  In a similar way, the following operation finds all values
of a name in an MVCNset, no matter how many.

\begin{Df}\label{df:mvcn-dereferencing}
Given a $(V,D)$-MVCNset~$p$ and a name~$v\in V^\ast$, \emph{dereferencing}
of~$v$ in~$p$ is
\[
  \deref{p}{v} = p[v] = \{ d | (v, d) \in p \} .
\]
where $p[v]$ means a complete image of~$v$ against a non-functional binary
relation~$p$.
\end{Df}

Dereferencing distributes over set-theoretical operations:
\begin{St}\label{st:mvcn-deref-distributivity}
Let~$\odot$ stand for either~$\cup$ or~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-MVCNsets. Then
\[
  \deref{p\odot q}{v} = \deref{p}{v} \odot \deref{q}{v} ,
\]
for every~$v\in V^\ast$.
\end{St}

\begin{Df}\label{df:mvcn-extremes}
Let us introduce special terms and symbols for the two extreme cases of
MVCNsets, namely:
\begin{itemize}
\item \emph{Empty}: $\bot = \varnothing$;
\item \emph{Full}: $\top = V^\ast \times D$.
\end{itemize}
\end{Df}
Obviously,
\begin{St}\label{st:mvcn-extreme-deref}
For any~$v\in V^\ast$,
\begin{eqnarray*}
  & \deref{\bot}{v} = \varnothing, \\
  & \deref{\top}{v} = D .
\end{eqnarray*}
\end{St}
It is easy to see that~$\bot$ and~$\top$ are neutral elements
of~$\cup$ and~$\cap$, respectively:
\begin{St}\label{st:mvcn-neutrals}
For any MVCNset~$p$,
\begin{eqnarray*}
  & \bot \cup p = p, \\
  & \top \cap p = p .
\end{eqnarray*}
\end{St}

Note that a compound name~$v$ in a MVCNset~$p$ not only is a reference to
multiple values but also is a common prefix for a ``bunch'' of names starting
with~$v$. In this sence,~$v$ is a name for an entire selection MVCNset that is
formalised in the following
\begin{Df}\label{df:mvcn-select}
Let~$p\in\setmvcn{V}{D}$, $v\in V^\ast$, then \emph{selection} from~$p$
under~$v$ is
\[
  \select(p,v) = \{ (w, d) \mid (vw, d)\in p \} .
\]
\end{Df}

The followig properties of selection are obvious:
\begin{St}\label{st:mvcn-selection-properties}
For any~$p,q\in\setmvcn{V}{D}$, $u, v\in V^\ast$, $\odot\in\{\cup, \cap\}$,
\begin{eqnarray*}
  & \select(p,\varepsilon) = p, \\
  & \select(p,uv) = \select(\select(p,u), v), \\
  & \select(p\odot q, v) = \select(p,v)\odot \select(q,v).
\end{eqnarray*}
\end{St}

It is interesting to note that there is another formalization of the
multivalued naming that is, however, equivalent to the above definitions.  It
is described in the next section.

\section{Alternative definition}

% todo: raname MTs here
\begin{Df}
A \emph{$(V,D)$-multitrie} is a total mapping
\[
  p : V^\ast \to 2^D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``multitrie''. A set of $(V,D)$-multitries will be
denoted~$\setmt{V}{D}$.\qed
\end{Df}

In other words, a multitrie could be regarded as a naming set whose names are
compound names and denotata are sets of objects from~$D$. The only special
detail here is totality of~$p$: every compound name has some value.

\begin{Df}
A multitrie~$p$ is called \emph{empty} (\emph{full}) and denoted~$\mtempty$
(respectively,~$\mtfull$) if $p(v)=\varnothing$ (resp., $p(v)=D$) for any~$v\in
N^\ast$.
\end{Df}

\begin{Df}
Let~$v$ be some compound name and~$A$ be some set of values, $v\in V^\ast$,
$A\subseteq D$.  Then~$p = \singleleaf(v,A)$ is such a multitrie that~$p(v) =
A$ and~$p(u) = \varnothing$ for any $u\in V^\ast$, $u\neq v$.
\end{Df}

\begin{Df}\label{df:select}
Let~$p\in\setmt{V}{D}$, $v\in V^\ast$, then
\[
  \select(p,v) = \{ (w, p(vw)) \mid w\in V^\ast \} .\qedhere
\]
\end{Df}

Obviously, for any multi-trie~$p$ and compound names~$u,v$:
\begin{eqnarray*}
  & \select(p,\varepsilon) = p ,\\
  & \select(p,uv) = \select(\select(p,u), v) .
\end{eqnarray*}

Operations similar to those of set theory can be naturally defined for multitries.

\begin{Df}\label{df:union-intersection}
Let~$\odot$ stand for any of~$\cup$ and~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-multitries. Then their \emph{union} and \emph{intersection} are
$(V,D)$-multitries, such that
\[
  (p\odot q)(v) = p(v) \odot q(v) ,
\]
for every~$v\in V^\ast$.\qed
\end{Df}

Obviously, empty and full multitries are neutral elements of union and intersection,
respectively. These operations are commutative, associative and idempotent.
Moreover, these operations are distributive against selection:
\[
  \select(p\odot q, v) = \select(p, v) \odot \select(q, v) .
\]

\begin{Df}\label{df:cartesian}
Let~$p$ and~$q$ be $(V,D')$- and $(V,D'')$-multitries, respectively. Their
\emph{cartesian product} $p\times q = r$ is a $(V,D'\times D'')$-multitrie
such that
\[
  r(w) = \bigcup_{u,v\in V^\ast: uv = w} p(u) \times q(v)
\]
for any~$w\in V^\ast$.\qed
\end{Df}

Obviously,~$\times$ is distributive against $\cap$ and $\cup$:
\[
  p\times(q\dot r) = p\times(q\dot r)
\]

Consider a multitrie whose values are, in their turn, multitries.
Flattening operation formally defined below turns it into a ``plain'' multitrie.
\begin{Df}\label{df:flatten}
\emph{Flattening} is an unary operation $\flatten : \setmt{V}{\setmt{V}{D}}
\to\setmt{V}{D}$, such that, for any $(V,\setmt{V}{D})$-multitrie~$p$, the
corresponding $r=\flatten(p)$ is defined by
\[
  r(w) = \bigcup_{u,v\in V^\ast: uv = w} p(u)(v)
\]
for any name~$w\in V^\ast$.\qed
\end{Df}

It is easy to see that the above definitions are equivalent to the following:
\begin{eqnarray}
  \label{eq:alt-cartesian}
  p\times q =
    \bigcup_{u,v\in V^\ast} \singleleaf(uv, p(u) \times q(v)) ,\\
  \label{eq:alt-flatten}
  \flatten(p) =
    \bigcup_{u,v\in V^\ast} \singleleaf(uv, p(u)(v)) .
\end{eqnarray}
(note that~$\cup$ in the definitions~\ref{df:cartesian} and~\ref{df:flatten}
means a set-theoretical union whereas in~(\ref{eq:alt-cartesian})
and~(\ref{eq:alt-flatten}) it means union of multitries, see
def.~\ref{df:union-intersection}).

\section{Constructional approach}

The above definition is abstract in the sense that it only describes how do
multitries look like from outside~-- namely, as a correspondence between
compound names and their values.

\section{Notes about implementation}

\section{Application}

\end{document}

