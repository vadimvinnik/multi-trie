%-------------------------------------------------------------------
%
% Author    : Vadim Vinnik
% E-mail    : vadim.vinnik@gmail.com
% Status    : Draft
% License   : Creative commons
%
%-------------------------------------------------------------------

\documentclass{article}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{dirtree}
\usepackage{listings}
\usepackage{stackrel}

\lstloadlanguages{Haskell}
\lstset{%
  basicstyle={\small\ttfamily},%
  language=Haskell%
}

\DTsetlength{0.2em}{2em}{0.2em}{0.4pt}{1pt}

\theoremstyle{definition}
\newtheorem{Df}{Definition}
\newtheorem{St}{Statement}
\newtheorem{Ex}{Example}

\newcommand{\setcharmvcn}{M}
\newcommand{\setcharmt}{T}

\newcommand{\setsymbol}[3]{\mathcal{#1}_{#2,#3}}

\newcommand{\setmvcn}[2]{\setsymbol{\setcharmvcn}{#1}{#2}}
\newcommand{\setmt}[2]{\setsymbol{\setcharmt}{#1}{#2}}

\newcommand{\seta}{\mathcal{A}}
\newcommand{\setn}{\mathcal{N}}

\newcommand{\flatten}{\operatorname{Fl}}
\newcommand{\select}{\operatorname{Sel}}
\newcommand{\deref}{\operatorname{Get}}
\newcommand{\putval}{\operatorname{Put}}
\newcommand{\proj}[2]{\operatorname{pr}^{#1}_{#2}}
\newcommand{\fmap}{\operatorname{Map}}
\newcommand{\fpam}{\operatorname{Pam}}
\newcommand{\id}{\operatorname{id}}
\newcommand{\apply}{\operatorname{Apply}}
\newcommand{\ylppa}{\operatorname{Ylppa}}
\newcommand{\eval}{\operatorname{Eval}}

\newcommand{\inapply}[1]{\stackbin{#1}{\nabla}}



\title{Compound names with multiple values: formalisation, properties and implementation}
\author{Vadim Vinnik}
\date{2016}



\begin{document}

\maketitle

\begin{abstract}
Naming is one of the most fundamental concepts in programming.  In most
cases, a name is considered to be atomic and to have a unique value.  This
paper describes a kind of naming with both these principles negated: names form
a monoid under concatenation, and each name can be associated with multiple
values.  Two different but equivalent formalisations are defined, their
isomorphism is shown.  Counterparts of set-theoretical union, intersection and
cartesian product operations are described together with their properties.  A
data type implementing this kind of naming is designed in Haskell, it fits into
functor, applicative functor and monad classes.

Keywords:
applicative functor,
atomicity,
cartesian product,
compoundness,
concatenation,
denotation,
dereferencing,
functor,
Haskell,
implementation,
intersection,
monad,
monoid,
multivaluedness,
name,
relation,
set,
trie,
union.
\end{abstract}



\tableofcontents



\section{Introduction}

A trilateral relation between a \emph{name}, its \emph{value} and
\emph{meaning} has been in the focus of philosophical and mathematical logic,
metamathematics, semiotics and epistemology since their origin.
For example, important questions
about naming were raised and deeply investigated in fundamental works by
G.\,Frege~\cite{bib:frege},
L.\,Wittgenstein~\cite{bib:wittgenstein},
W.\,Quine~\cite{bib:quine}.
With arising of computer science, naming gained a special significance~-- for
example, \emph{a name that refers to a name that, finally, relates to an
entity} is not a purely philosophical excercise anymore but a working tool for
everyday~-- an \emph{indirect pointer}; a question \emph{does every name
necessarily have a value} turned into a \emph{null reference} with both its
power and danger; \emph{names changing their values depeding on the context}
became \emph{variables} in the sense of imperative programming. Since
\emph{addresses} of some entities in memory are obviously a special case of
names, and since addresses are, in their turn, values that can be computed,
relationship and interaction between names and values in programming is even
more complicated than in pre-computer semiotics.

Therefore, every comprehensive theory of programming must give a special
explication of naming and include a mathematical model that reflects its
properties and behaviour.  Approaches and formal techniques could be very
different.  For example, \emph{A Practical Theory of
Programming}~\cite{bib:ptop} as well as a much earlier book \emph{Unifying
Theories of Programming}~\cite{bib:utp} represent a variable declaration by
means of a quantifier.

As always in the first-order logic, a name bound by a quantifier refers to an
unspecified object of the semantic domain; the formula tells something about
the objects and uses names to represent them.  Objects belong to a semantic
level, and names to the syntactical level that do not intersect.  Therefore,
this formalism works fine for the wide class of programs that have a predefined
list of variables but hardly can describe programs that dynamically allocate
memory for objects whose number is \emph{a priori} unknown.  In general,
high-level theories of programming deliberately distantiate from hardware and
OS details.

On the contrast to above, there are theories that explicitly describe memory
model and allocation operations in terms of memory block
references~\cite{bib:leroy}.  These theories reflect semantics of programs on a
relatively low, implementation-aware level, and their primary application is
formal specification and verification of compilers.

There is yet another option between these two extremes.  Names can be regarded
as computable values without cumbersome specifics of \emph{being addresses}.  A
typical example arises from array processing: \lstinline{a[i]} is a computable
name because this expression, depending on the value of an integer
variable~\lstinline{i}, evaluates to any of individual elements' names.

An elegant and general formalism for naming that does not burden names
with any alien specifics, but allows any specifics to be added if needed,
is a notion of \emph{naming set} introduced by V.\,N.\,Redko in a
comprehensive conception of \emph{compositional programming}~\cite{bib:redko}.

\begin{Df}\label{df:naming-set}
Suppose there is a given set~$D$ whose elements are called \emph{values}, or
\emph{denotata}, and a set~$V$ of objects called \emph{names}.
A \emph{$(V,D)$-naming set} (the prefix will be omitted when possible) is a
partial mapping $s: V\to D$.
\end{Df}

In other words, a naming set is an object of the form
\[
  s = \{ (v_1, d_1), (v_2, d_2), \ldots, \} ,
\]
where $v_i\in V$, $d_i\in D$, and all~$v_i$ are pairwise distinct. The
latter requirement formalizes \emph{unambiguity}, or \emph{univaluedness}: a
name cannot have different values in a given context.

\begin{Ex}\label{ex:naming-set}
A naming set $s = \{ (a, 1), (t, 7), (w, 1) \}$ represents a context where
the name~$a$ has a value~1, the name~$b$ refers to a value~7 and the name~$w$
denotes~1, no other names have values.
\end{Ex}

A set-theoretical intersection  of naming sets is obviously a naming set
whereas a union is not because it can violate univaluedness:
\[
  \{ (a, 0) \} \cup \{ (a, 1) \} = \{ (a, 0), (a, 1) \} .
\]

Naming mappings defined as above are widely used in theoretical computer
science for syntactical as well as semantical tasks, a good example could be
an approach to definition of programming languages~\cite{bib:ollongren}.
\emph{Maps}, \emph{dictionaries}~\cite{bib:dictionary} and \emph{associative
arrays}~\cite{bib:mehlhorn-assoc}~-- abstract data types
implementing the same idea, are included into standard libraries of various
programming languages and widely used in practice.

At the topmost abstraction level, a naming set represents a ``plain'' relation
where names and values are atomic in the sense that their internal structures
and any non-trivial properties are hidden as irrelevant.  In fact, the only
special property taken into account by the definition above is equatability of
names: for any two names, it should be possible to decide whether they are
identical.

Although def.~\ref{df:naming-set} does not mention or use any special properties
of names and values, it does not require their absense.
Introducing various properties of names and/or denotata, one can obtain a
number of interesting and useful specialised formalisations of naming for
theoretical purposes as well as implementable data structures suitable for
practical tasks. This article describes a kind of naming with
two important differences from the definition~\ref{df:naming-set}.
\begin{itemize}
\item \emph{Multivaluedness}: any name can be related to zero or more values;
\item \emph{Compoundness of names}: compound names could be concatenated from
shorter ones, i.e. names form a monoid under concatenation.
\end{itemize}

\subsection*{Conventions about notation}

For any set~$X$, let~$X^\ast$ denote a set of all sequences of its elements
(also known as \emph{chains}), and~$2^X$ be a set of all its subsets.
If~$a,b\in X^\ast$ are two chains, their concatenation will be denoted simply
as~$ab$. Let~$\varepsilon$ stand for the empty chain.
Let $\proj{n}{k}$ be a function that maps an $n$-tuple to its $k$-th component.

A set of Latin letters (the alphabet) is denoted as~$\seta$,
and~$\setn$ will denote a set of natural numbers~-- these two sets will be
used in examples.
Some more notations will be introduced later, immediately before they are used.



\section{Relation-based definition and basic properties}

Let~$V$ be a given set of objects called \emph{atomic names}. Elements
of~$V^\ast$ are called \emph{compound names}. Let us omit the words ``atomic''
and ``compound'' if it does not lead to confusion.

\begin{Df}\label{df:mvcn}
A \emph{$(V,D)$-multi-valued compound-naming set, or $(V,D)$-MVCNset,} is a binary
relation
\[
  p \subseteq V^\ast \times D .
\]
Whenever $V$ and $D$ are obvious from the context, we'll omit ``$(V,D)$-''
prefix and write simply ``MVCNset''. A set of $(V,D)$-MVCNsets will be
denoted~$\setmvcn{V}{D}$.
\end{Df}

Note that there is an obvious bijection between a class of $(V,D)$-MVCNsets and
a class of $(V^\ast, 2^D)$-naming sets: a relation between a name and its
multiple values could be modelled through a single value that is a subset
of~$V$. Therefore, a multivalued naming could be regarded as a special case of
an univalued naming with extra specifics applied to values.

\begin{Ex}\label{ex:mvcn}
The following is a $(\seta, \setn)$-MVCNset:
\[
  p = \{
    (\varepsilon, 0),
    (\varepsilon, 1),
    (a,           2),
    (a,           3),
    (a,           4),
    (aa,          5),
    (ab,          6),
    (b,           7),
    (baaa,        8)
  \} .
\]
Here the empty name has two values (0 and~1), name~$a$ has three (2, 3 and~4),
comound names~$aa$ and~$ab$ have each a single value (5 and~6, respectively),
name~$b$ has a value~7 and, finally, a name~$baaa$ has one value~8. All other
names from~$\seta^\ast$ have no values.
\end{Ex}

Note that, in contrast with naming sets, no special conditions are imposed
on an MVCNset~--- it is just an arbitrary set of name-value pairs.
Therefore, $\setmvcn{V}{D}$ is closed against set-theoretical union
and intersection.
\begin{St}\label{st:mvcn-setop}
If~$p$ and~$q$ are $(V,D)$-MVCNsets, so are~$p\cup q$ and~$p\cap q$.
\end{St}

When it is important to emphasise that union and intersection are operations
on MVCNsets rather than on general case of sets, we will
write~$\cup_\setcharmvcn$ and~$\cap_\setcharmvcn$.

One of the fundamental operations on (univalued) naming sets is retrieving
an only (if any) value~$d$ associated with the name~$v$ in a naming
set~$s$.  Depending on the goals and abstraction level of a particular
context, it could be regarded either as~$s(v)=d$, i.e. applying a function~$s$
to an argument~$v$, or as an operation whose arguments are the naming set and
the name, i.e.~$\deref(s, v)=d$. Its counterpart in MVCNset world that
retrieves all values of a name, no matter how many, obviously cannot be denoted
using the first style because MVCNsets, as general binary relations, need not
to be functional.

\begin{Df}\label{df:mvcn-dereferencing}
\emph{Dereferencing} is an operation~$\deref_\setcharmvcn$ (or, whenever
possible, omiting the subscript, simply~$\deref$) of type
$\setmvcn{V}{D} \times V^\ast \to 2^D$,
such that
\[
  \deref_\setcharmvcn(p, v) = \{ d \mid (v, d) \in p \} .
\]
\end{Df}

Unlike the univalued case, here~$\deref$ is a total operation: even if a
name~$v$ does not have any associated value in an MVCNset~$p$, dereferencing
it just yields an empty set of values.

\begin{Ex}\label{ex:mvcn-dereferencing}
Consider an MVCNset~$p$ from ex.~\ref{ex:mvcn}. Then
\begin{eqnarray*}
  \deref(p, \varepsilon) & = & \{ 0, 1 \}, \\
  \deref(p, baaa)        & = & \{ 8 \}, \\
  \deref(p, cdcd)        & = & \varnothing .
\end{eqnarray*}

\end{Ex}

It follows immediately from the definition that dereferencing distributes
over set-theoretical operations.
\begin{St}\label{st:mvcn-deref-distributivity}
Let~$\odot$ stand for either~$\cup$ or~$\cap$, and let~$p$ and~$q$ be
$(V,D)$-MVCNsets. Then, for every~$v\in V^\ast$,
\[
  \deref(p\odot q, v) = \deref(p, v) \odot \deref(q, v) .
\]
\end{St}

The following important property means, in fact, that any MVCNset is completely
defined by the values of all its names.  In terms of programming, it means that
if two MVCNset objects' behaviours (observed through the $\deref$ selector) are
indiscernible, the objects are identical.
\begin{St}\label{st:mvcn-deref-equality}
Let $p, q \in \setmvcn{V}{D}$. Then
\[
  (\forall u\in V^\ast . \deref(p,u) = \deref(q,u)) \implies (p = q) .
\]
\end{St}

The following operation is, in a reasonable sense, an opposite to
dereferencing.  It replaces all values of some name with a new set of values.
Thus, it is similar to assignment in the sense of imperative programming.
\begin{Df}\label{df:mvcn-replace}
\emph{Replacement} is an operation
\begin{eqnarray*}
 & \putval_\setcharmvcn :
    \setmvcn{V}{D} \times V^\ast \times 2^D \to \setmvcn{V}{D}, \\
 & \putval_\setcharmvcn(p, u, s) =
      \{ (v, x) \mid (v, x) \in p, v \neq u \} \cup
      \{ (u, y) \mid y \in s \} .
\end{eqnarray*}
The subscript will be omitted further whenever possible.
\end{Df}
In other words, this operation deletes from~$p$ all values corresponding to
the name~$u$, leaves all other name-value pairs intact and assigns new values
to the~$u$.

\begin{Ex}\label{ex:mvcn-replace}
Let~$p$ be an MVCNset from ex.~\ref{ex:mvcn}. Then
\[
  \putval(p, a, \{ 9, 10 \}) = \{
    (\varepsilon, 0),
    (\varepsilon, 1),
    (a,           9),
    (a,           10),
    (aa,          5),
    (ab,          6),
    (b,           7),
    (baaa,        8)
  \} .
\]
\end{Ex}

The main property of replacement is obvious and immediately follows from the
definition: it changes the values of one name and does not influence the other
names. Except this, two replacement operations commute if they
relate to different names, otherwise the outer operation absorbs the inner one.
\begin{St}\label{st:mvcn-replace-deref}
Let~$p \in \setmvcn{V}{D}$, $u, v \in V^\ast$, $s \in 2^D$. Then
\begin{eqnarray*}
  & \deref(\putval(p, u, s), u) = s , \\
  & u \neq v \implies \deref(\putval(p, u, s), v) = \deref(p, v) , \\
  & \putval(\putval(p, u, s), u, t) = \putval(p, u, t) , \\
  & u \neq v \implies \putval(\putval(p, u, s), v, t) = \putval(\putval(p, v, t), u, s) .
\end{eqnarray*}
\end{St}

Let us introduce special terms and symbols for the two extreme cases of
MVCNsets, namely:
\begin{Df}\label{df:mvcn-extreme}
MVCNsets $\bot_\setcharmvcn$ called \emph{empty} and $\top_\setcharmvcn$ called
\emph{full} are defined by
\begin{eqnarray*}
  \bot_\setcharmvcn &  = &  \varnothing ; \\
  \top_\setcharmvcn &  = &  V^\ast \times D .
\end{eqnarray*}
Further, we'll omit the subscript when it does not lead to confusion.
\end{Df}

In other words, each name in the empty MVCNset has no value whereas in the
full MVCNset every name has all possible values. Let us formalize this
elementary fact for the further use.
\begin{St}\label{st:mvcn-extreme-deref}
For any~$v\in V^\ast$,
\begin{eqnarray*}
  \deref(\bot, v) & = & \varnothing, \\
  \putval(\bot, v, \varnothing) & = & \bot , \\
  \deref(\top, v) & = & D , \\
  \putval(\top, v, D) & = & \top .
\end{eqnarray*}
\end{St}

The next property is also just a trivial consequence of the definition:~$\bot$
and~$\top$ are units of~$\cup$ and~$\cap$, respectively and zeros vice versa.
\begin{St}\label{st:mvcn-neutrals}
For any MVCNset~$p$,
\begin{eqnarray*}
  \bot \cup p & = & p,    \\
  \top \cap p & = & p,    \\
  \bot \cap p & = & \bot, \\
  \top \cup p & = & \top.
\end{eqnarray*}
\end{St}

Note that a compound name~$v$ in a MVCNset~$p$ not only is a reference to
multiple values but also is a common prefix for a ``bunch'' of names starting
with~$v$. In this sence,~$v$ is a name for an entire sub-object of~$p$ that is
defined as follows.
\begin{Df}\label{df:mvcn-select}
Let~$p\in\setmvcn{V}{D}$, $v\in V^\ast$, then \emph{selection} from~$p$
under~$v$ is
\[
  \select_\setcharmvcn(p,v) = \{ (w, d) \mid (vw, d)\in p \} \in\setmvcn{V}{D}.
\]
As always, the subscript will be omited if possible.
\end{Df}

\begin{Ex}\label{ex:mvcn-select}
Let~$p$ be an MVCNset from ex.~\ref{ex:mvcn}, then
\begin{eqnarray*}
  \select(p, a) & = & \{
    (\varepsilon, 2),
    (\varepsilon, 3),
    (\varepsilon, 4),
    (a,           5),
    (b,           6)
  \} , \\
  \select(p, b) & = & \{
    (\varepsilon, 7),
    (aaa,         8)
  \} , \\
  \select(p, cdcd) & = & \bot .
\end{eqnarray*}
\end{Ex}

\begin{St}\label{st:mvcn-selection-properties}
For any~$p,q\in\setmvcn{V}{D}$, $u, v\in V^\ast$, $\odot\in\{\cup, \cap\}$,
\begin{eqnarray*}
  & \select(\bot,u) = \bot, \\
  & \select(\top,u) = \top, \\
  & \select(p,\varepsilon) = p, \\
  & \select(p,uv) = \select(\select(p,u), v), \\
  & \select(p\odot q, u) = \select(p,u)\odot \select(q,u).
\end{eqnarray*}
\end{St}
In other words,
\begin{itemize}
\item $\select$~preserves empty and full MVCNset;
\item selection under an empty name is an identity over MVCNsets;
\item selection under a compound name can be performed by parts;
\item selection is distributive over union and intersection.
\end{itemize}

It is interesting to note that there is another formalization of the
multivalued naming that is, however, equivalent to the above definitions.  It
is described in the next section.



\section{Trie-based definition}

Take a closer look at the MVCNset~$p$ from ex.~\ref{ex:mvcn}.
Recall the
idea underlying selection operation: that any name~$u$ identifies a bunch of
names that have~$u$ as its common prefix. Except this, take into account that
the empty name~$\varepsilon$ is a common prefix for all names.

The name~$\varepsilon$, the simplest name ever, refers in~$p$ to a set of
values~$\{0,1\}$. Name~$a=\varepsilon a$ is an extension of~$\varepsilon$ by
one atomic name and refers to values~$\{2,3,4\}$. In its turn, name~$a$ can
be extended by one atomic name to~$aa$, $ab$, \ldots, $az$, from which only the
former two are of intrest because their sets of values are non-empty.
Now return to the empty name and compose another its continuation, namely~$b$.
This name is a prefix for~$ba$ that, in its turn, can be extended to~$baa$ and
then to~$baaa$.

All this gives a hierarchical view of~$V^\ast$ where
\begin{itemize}
\item the highest member of the hierarchy is the empty name;
\item appending an atomic component to a name moves one level deeper;
\item having a common prefix means having a common ancestor.
\end{itemize}
The hierarchical representation of the MVCNset~$p$ is shown on the
fig.~\ref{fig:trie}.

\begin{figure}[ht]
\begin{center}
\begin{minipage}{17em}
\dirtree{%
  .1 $\varepsilon$\DTcomment{$\{0, 1\}$} .
    .2 $a$\DTcomment{$\{2, 3, 4\}$} .
      .3 $a$\DTcomment{$\{5\}$} .
      .3 $b$\DTcomment{$\{6\}$} .
    .2 $b$\DTcomment{$\{7\}$} .
      .3 $a$\DTcomment{$\varnothing$} .
        .4 $a$\DTcomment{$\varnothing$} .
          .5 $a$\DTcomment{$\{8\}$} .
}
\end{minipage}
\end{center}
\caption{A multitrie corresponding to the MVCNset~$p$}\label{fig:trie}
\end{figure}

To grasp this informal consideration in a definition, it would be convenient to
assume that every node in the hierarchy has \emph{all} possible children (i.e.
that the hieraarchy includes all names from~$V^\ast$ regardless of whether they
have values): otherwise we needed a special treatment for missing names in
every subsequent definition or statement. This leads to the following

\begin{Df}\label{df:mt}
A class of \emph{$(V,D)$-multitries} (or simply \emph{multitries} when~$V$
and~$D$ are known from the context or irrelevant):
\[
  \setmt{V}{D} = 2^D \times (V \to \setmt{V}{D}) .
\]
\end{Df}

In other words, a $(V,D)$-multitrie is a pair $p = (s, f)$ where~$s\subseteq D$
is a set of values and $f: V \to \setmt{V}{D}$ is a function that maps any
atomic name to some $(V,D)$-multitrie. Note that this recursive definition does
not have any basic case: every multitrie contains sub-multitries (that, in
their turn, have the same structure) under all atomic names, there are no leaf
nodes.
Depicting multitries graphically, as on fig.~\ref{fig:trie}, we will however
only draw nodes of interest assuning that all other nodes have empty sets of
values.

Note that a $(V,D)$-multitrie is a \emph{trie} also known as
a prefx tree~\cite{bib:knuth-trie}~-- that justifies their name.

Extreme multitries have the following recurrent definitions.
\begin{Df}\label{df:mt-extreme}
\emph{Empty} and \emph{full} $(V,D)$-multitries:
\begin{eqnarray*}
  \bot_\setcharmt & = &
      ( \varnothing, \{ v \mapsto \bot_\setcharmt \mid v\in V \} ) , \\
  \top_\setcharmt & = &
      ( D,           \{ v \mapsto \top_\setcharmt \mid v\in V \} ) .
\end{eqnarray*}
Subscripts will be further omited whenever possible.
\end{Df}
In other words, empty (full) multitrie is a multitrie that has an empty
(full) set of values and whose children under all atomic names are, in their
turn, empty (full) multitries.

\begin{Df}\label{df:mt-select}
\emph{Selection} operation. Let $p=(s,f) \in \setmt{V}{D}$, $u\in V$,
$v\in V^\ast$, then
\begin{eqnarray*}
  \select_\setcharmt(p, \varepsilon) & = & p , \\
  \select_\setcharmt(p, u v) & = & \select_\setcharmt(f(u), v) .
\end{eqnarray*}
Subscripts will be omited if possible.
\end{Df}

In other words, selection operation finds a node pointed to by the
compound name as a path in the trie.
Selection is the basic operation on multitries.

\begin{Ex}\label{ex:mt-select}
Consider a multitrie~$p$ depicted on fig.~\ref{fig:trie}. Selection under a
name~$a$ results in a multitrie~$\select(p,a)$ shown on
fig.~\ref{fig:mt-select}.
\end{Ex}

\begin{figure}[ht]
\begin{center}
\begin{minipage}{17em}
\dirtree{%
  .1 $\varepsilon$\DTcomment{$\{2, 3, 4\}$} .
    .2 $a$\DTcomment{$\{5\}$} .
    .2 $b$\DTcomment{$\{6\}$} .
}
\end{minipage}
\end{center}
\caption{Selection of a multitrie}\label{fig:mt-select}
\end{figure}

\begin{Df}\label{df:mt-deref}
Given a $(V,D)$-multitrie~$p$ and a name~$v\in V^\ast$, \emph{dereferencing}
of~$v$ in~$p$ is
\[
  \deref_\setcharmt(p, v) = \proj{2}{1}(\select(p, v)) .
\]
As always, we'll not write the subscript if it is obvious from the context.
\end{Df}

In other words, if $\select(p,v) = (s,f)$, then $\deref(p, v) = s$. To
dereference a name in a multitrie, one needs to follow the compound name
as a path to a node in the trie and then take the value stored in that node.

Union and intersection could be defined for multitries.
\begin{Df}\label{df:mt-setop}
Let $\odot \in \{ \cup, \cap \}$, $p, q \in \setmt{V}{D}$,
$p = (s,f)$, $q = (t, g)$. Then
\[
  p \odot_\setcharmt  q = (s \odot t, \{ v \mapsto f(v) \odot_\setcharmt  g(v) \mid v \in V \}) .
\]
Note that subscripts in this definition help to distinguish between
set-theoretical operations on sets of values and corresponding operations
on multitries.
\end{Df}

In other words, to build $r = p \cup q$, one needs, for each compound name,
build the union of the value sets contained in the operands under that name.

Let us also define for multitries an operation that corresponds to replacement
defined for MVCNsets (see def.~\ref{df:mvcn-replace}. Like other multitrie
operations, the most natural way of defining it is recursive.
\begin{Df}\label{df:mt-replace}
\emph{Replacement} is an operation $\putval_\setcharmt : \setmt{V}{D}
\times V^\ast \times 2^D \to \setmt{V}{D}$, such that, for any
$p = (s, f) \in \setmt{V}{D}$, $t \in 2^D$, $u \in V$, $v \in V^\ast$,
\begin{eqnarray*}
  \putval_\setcharmt(p, \varepsilon, t) & = & (t, f) , \\
  \putval_\setcharmt(p, u v, t) & = & (s, f') ,
\end{eqnarray*}
where $f' : V \to \setmt{V}{D}$ is such a function that $f'(w) = f(w)$ for any
$w\neq u$, and $f'(u) = \putval_\setcharmt(f(u), v, t)$.
The subscript after the operation will be omited whenever it does not lead to
confusion.
\end{Df}

In other words, to perform a replacement in a multitrie, one has to distunguish
between two cases. If the name to be replaced is empty, just replase the set of
values in the root node of the trie. Otherwise, take the first atomic component
of the name, go to the child node associated with that atom, and perform a
replacement under a remainder of the name.

It is easy to see that properties identical to those of MVCNsets
hold for multitries, namely counterparts of
st.~\ref{st:mvcn-deref-distributivity},
\ref{st:mvcn-deref-equality},
\ref{st:mvcn-replace-deref},
\ref{st:mvcn-extreme-deref},
\ref{st:mvcn-neutrals}
and~\ref{st:mvcn-selection-properties}.
Moreover, all properties of MVCNsets and multitries are identical because
of the following.

\begin{St}\label{st:isomorph}
Consider a mapping~$\varphi: \setmvcn{V}{D} \to \setmt{V}{D}$, such that,
for any~$p\in \setmvcn{V}{D}$,
\[
  \varphi(p) = (
    \deref_\setcharmvcn(p, \varepsilon) ,
    \{ u \mapsto \select_\setcharmvcn(p, u) \mid u\in V \}
  ) .
\]
Then~$\varphi$ is a bijection that preserves
extreme elements, union, intersection, dereferencing, replacement and selection
operations:
\begin{eqnarray*}
  & \varphi(\bot_{\setcharmvcn}) = \bot_{\setcharmt}, \\
  & \varphi(\top_{\setcharmvcn}) = \top_{\setcharmt}, \\
  & \varphi(p \mathbin{\odot_{\setcharmvcn}} q) =
      \varphi(p) \mathbin{\odot_{\setcharmt}} \varphi(q) , \\
  & \deref_{\setcharmvcn}(p, v) =
      \deref_{\setcharmt}(\varphi(p), v) , \\
  & \putval_{\setcharmvcn}(p, v, s) =
      \putval_{\setcharmt}(\varphi(p), v, s) , \\
  & \varphi(\select_{\setcharmvcn}(p, v)) =
      \select_{\setcharmt}(\varphi(p), v) .
\end{eqnarray*}
\end{St}

In other words, $\varphi$~is an isomorphism from many-sorted algebra of
MVCNsets to an algebra of multitries.
This allows us to switch flexibly between MVCNset and multitrie
languages when describing further notions, choosing the most
appropriate form in each particular case.



\section{Cartesian product and flattening}

Operations described in the previous section (union, intersection, selection)
preserve the type and structure of their operands. This section describes two
more complicated operations.

Before giving a formal definition for a cartesian product of namings, let us
informally describe how should an operation look like to deserve this name.
Let~$p$ and~$q$ be two MVCNsets. Their cartesian product should consist of
values of the form~$(d',d'')$ where $d'$~is a value from~$p$ and $d''$~is taken
from~$q$. But values are attached to some names~-- say, $u$~and~$v$,
respectively. As the product's value~$(d',d'')$ is combined from the values
taken from operands, the name of this combined value must be combined from~$u$
and~$v$, and the only combining operation defined for names is concatenation.

\begin{Df}\label{df:mvcn-cartesian}
Let~$p$ and~$q$ be $(V,D')$- and $(V,D'')$-MVCNsets, respectively. Their
\emph{cartesian product} is a $(V,D'\times D'')$-MVCNset
\[
  p\times q = \{ (uv, (d',d'')) \mid (u,d')\in p, (v,d'')\in q \} .
\]
\end{Df}

\begin{Ex}\label{ex:cartesian}
Consider the following MVCNsets:
\begin{eqnarray*}
  p & = & \{ (\varepsilon, 0), (a, 1), (a, 2) \} , \\
  q & = & \{ (\varepsilon, 3), (\varepsilon, 4), (b, 5) \} .
\end{eqnarray*}
Then their cartesian product is
\begin{eqnarray*}
  p \times q & = &  \{ (\varepsilon, (0, 3)), (\varepsilon, (0, 4)) \} \cup \\
    & \cup & \{ (b, (0, 5)) \} \cup \\
    & \cup & \{ (a, (1, 3)), (a, (1, 4)), (a, (2, 3)), (a, (2, 4)) \} \cup \\
    & \cup & \{ (ab, (1, 5)), (ab, (2, 5)) \} .
\end{eqnarray*}
\end{Ex}

\begin{St}\label{st:cartesian-distributivity}
Obviously,~$\times$ distributes over $\cap$ and $\cup$.
For any $p \in \setmvcn{V}{D}$ and $q, r \in \setmvcn{V}{D'}$,
\[
  p\times(q\odot r) = (p\times q) \odot (p\times r) .
\]
\end{St}

\begin{St}\label{st:deref-cartesian}
For any $p \in \setmvcn{V}{D'}$ and $q \in \setmvcn{V}{D''}$,
\[
  \deref(p \times q, w) =
      \bigcup_{u,v\in V^\ast: uv = w}
          \deref(p, u)
          \times
          \deref(q, v) .
\]
\end{St}

The latter is the main property of cartesian product. Since an MVCNset is
completely defined by values of all names (st.~\ref{st:mvcn-deref-equality}),
cartesian product can be defined in terms of dereferencing and, therefore,
is preserved by the mapping~$\varphi$ from st.~\ref{st:isomorph}. Also, this
property may be taken as a definition of cartesian product for multitries.

Consider an MVCNset~$p$ whose values are, in their turn, MVCNsets.
Flattening operation formally defined below turns it into a ``plain'' MVCNset.
First, let us describe the underlying idea. Supose a name~$u$ in~$p$ has a
value~$q$ (and, maybe, some other values) that, by precondition, is an
MVCNset.  Then take a name~$v$ that has a value~$d$ in~$q$. In sum, to
reach~$d$ from~$p$, one has to dereference the name~$u$ (obtaining~$q$) and
then (in~$q$) dereference~$v$. Therefore, flattening should turn~$p$ into
such an MVCNset~$r$, where~$d$ is a value of the name~$uv$.
\begin{Df}\label{df:flatten}
\emph{Flattening} is an unary operation
$\flatten : \setmvcn{V}{\setmvcn{V}{D}} \to\setmvcn{V}{D}$,
such that, for any $(V,\setmvcn{V}{D})$-MVCNset~$p$,
\[
  \flatten(p) = \{ (uv, d) \mid (u, q) \in p, (v, d) \in q \} .
\]
\end{Df}

\begin{Ex}\label{ex:flatten}
Let
\begin{eqnarray*}
  q_1 & = & \{ (\varepsilon, 0), (a, 1) \} ,\\
  q_2 & = & \{ (a, 2), (aa, 3) \} ,\\
  q_3 & = & \{ (\varepsilon, 4), (a, 5) \} ,\\
  p   & = & \{ (\varepsilon, q_1), (\varepsilon, q_2), (a, q_3) \} .\\
\end{eqnarray*}
Then
\[
  \flatten(p) = \{
      (\varepsilon, 0), (a, 1), (a, 2), (a, 4), (aa, 3), (aa, 5)
  \} .
\]
The empty name~$\varepsilon$ has two values in~$p$, namely~$q_1$ and~$q_2$.
In~$q_1$, in its turn, the only value of~$\varepsilon$ is~0, whereas in~$q_2$
it does not have any value. Therefore, 0~is the only value of $\varepsilon
\varepsilon = \varepsilon$ in~$\flatten(p)$.  The name~$a$ has one value in~$q_1$
and one value in~$q_2$, it is~1 and~2, respectively.  Then $a = \varepsilon a$
has values~1 and~2 in $\flatten(p)$.  The name~$a$ in~$p$ has a value~$q_3$
where the empty name's value is~4. Thus, 4~is also a value of $a \varepsilon =
a$ in~$\flatten(p)$.

Now look at the name~$aa$. Its value~3 is inherited from~$q_2$. Except this,
name~$a$ in~$p$ has a valaue~$q_3$ that, in its turn, contains a name~$a$ with
a value~5. Hence, the name~$aa$ has in $\flatten(p)$ the second value~5.
\end{Ex}

The following property can be used to define flattening for multitries~--
in terms of dereferencing operation.
\begin{St}\label{st:deref-flatten}
For any $(V,\setmvcn{V}{D})$-MVCNset~$p$,
\[
  \deref(\flatten(p), w) =
      \bigcup_{u,v\in V^\ast: uv = w}
        \deref(\deref(p, u), v) .
\]
\end{St}



\section{Elementwise mappings and applications}

The previous sections described operations on namings containing some
`ordinary' values. Now let us consider how do these objects interact with
functions, including how can a naming populated with functions act itself
as a function.

\begin{Df}\label{df:mvcn-map}
Let $f : D \to D'$. Then $\fmap$ operation turns it into a \emph{mapping
function} $\fmap_{\setcharmvcn} f : \setmvcn{V}{D} \to \setmvcn{V}{D'}$, such
that
\[
  (\fmap_{\setcharmvcn} f)(p) = \{ (v, f(d)) \mid (v, d) \in p \}
\]
for any $p \in \setmvcn{V}{D}$.
\end{Df}

The definition of mapping for multi-tries is straightforward, it can be easily
obtained from isomorphism. The following properties hold:

\begin{St}\label{st:map-properties}
If $\circ$ is a composition of unary functions, i.e. $(f\circ g)(x) = f(g(x))$ for
all $f$, $g$, $x$ of matching types, and $\id_X : X \to X$ is an identity function,
$\id_X(x) = x$ for any $x\in X$, then
\begin{eqnarray*}
  & \fmap \id_D = \id_{\setmvcn{V}{D}} , \\
  & \fmap (f \circ g) = (\fmap f) \circ (\fmap g) .
\end{eqnarray*}
\end{St}

\begin{St}\label{st:map-distributivity}
Mapping function distributes over set-theoretical operations.
Let $f: D \to D'$, $p, q \in \setmvcn{V}{D}$, $\odot \in \{\cup, \cap \}$. Then
\[
  (\fmap f) (p \odot q) = (\fmap f)(p) \odot (\fmap f)(q) .
\]
\end{St}

Thus, $\fmap$ operation can apply a single unary function to an MVCNset of
values. It is easy to define an operation $\fpam$ that does the opposite:
applies an MVCNset of unary functions to a single value. For this purpose,
let us define first an auxiliary function that turns a value~$x$ into a
high order function applying an argument function to~$x$:

\begin{Df}\label{df:ylppa}
\emph{Reverse application} is a function $\ylppa : X \to ((X \to Y) \to Y)$,
such that, for every $x\in X$, $\xi = \ylppa x$ is a function satisfying the
equation
\[
  \xi(f) = f(x)
\]
for every $f: X\to Y$.
\end{Df}

Then the reverse mapping operation gets a concise definition.

\begin{Df}\label{df:mvcn-pam}
\emph{Reverse mapping} is an operation
$\fpam_{\setcharmvcn} : \setmvcn{V}{D \to D'} \to (D \to \setmvcn{V}{D'})$,
such that
\[
  (\fpam p)(d) = (\fmap (\ylppa d))(p) .
\]
for any $p\in \setmvcn{V}{D}$, $d\in D$.
\end{Df}

It is easy to see from the definitions of $\fmap$ and $\ylppa$ that $\fpam$
really does what was intended:

\begin{St}\label{st:mvcn-pam}
If $p$ is a $(V, D\to D')$-MVCNset, $d\in D$,
\[
  (\fpam p)(d) = \{ (v, f(d)) \mid (v, f) \in p \} .
\]
\end{St}

Since reverse mapping is defined as a special case of mapping, it inherits
distributivity, see st.~\ref{st:map-distributivity}.

\begin{St}\label{st:pam-distributivity}
Let $d\in D$, $p, q \in \setmvcn{V}{D \to D'}$, $\odot \in \{\cup, \cap \}$. Then
\[
  (\fpam (p \odot q))(d) = (\fpam p)(d) \odot (\fpam q)(d) .
\]
\end{St}

Having defined operations that apply a single function to an MVCNset of values
and an MVCNset of functions to a single value, let us define an
operation that applies an MVCNset of functions to an MVCNset of values. The
operation must preserve trie-like naming structures of both operands~-- the
considerations motivating the definition of cartesian product apply here
as well. To avoid rewriting essentially the same definition twice, let us
instead introduce an auxiliary operation and reuse a previously defined
operation.

\begin{Df}\label{df:eval}
Operation $\eval$ called \emph{(unary) evaluation} has type
$(X \to Y) \times X \to Y$ and is defined as follows.
\[
  \eval (f, x) = f(x) .
\]
\end{Df}

In other words, this operation takes a pair whose first element is a unary
function and the second is an argument, and applies the function to the
argument. Thus, the application operation over MVCNsets can be defined as
follows.

\begin{Df}\label{df:mvcn-apply-cartesian}
Then \emph{cartesian application} is an operation of type
\[
\setmvcn{V}{D\to D'} \times \setmvcn{V}{D} \to \setmvcn{V}{D} ,
\]
such that
\[
  \apply_{\setcharmvcn}^{\times} (p, q) = (\fmap \eval) (p \times q)
\]
for any~$p$ and~$q$ of matching types.
\end{Df}

Recalling the definitions of cartesian product and evaluation, one can
obtain the main property of cartesian application (that could be also taken
for a definition, in which case def.~\ref{df:mvcn-apply-cartesian} would turn
into a theorem).
 
\begin{St}\label{st:mvcn-apply-cartesian}
If $p\in \setmvcn{V}{D\to D'}$, $p\in \setmvcn{V}{D}$,
\[
  \apply_{\setcharmvcn}^{\times} (p, q) =
    \{ (uv, f(d)) \mid (u,f) \in p, (v,d) \in q \} .
\]
\end{St}

Therefore, for every function~$f$ contained in~$p$ under a compound name~$u$
and every object~$d$ contained in~$q$ under a name~$v$, the resulting
multi-trie contains a value~$f(d)$ under a name~$uv$.

Cartesian is not the only kind of application with an elegant definition and
interesting properties.  The following two application operations are
easier to define in terms of multi-tries.

\begin{Df}\label{df:mt-apply-setop}
\emph{Uniting} and \emph{intersecting application} are operations
$\apply_{\setcharmt}^{\odot}$, where $\odot \in \{\cup, \cap \}$, of type
\[
  \setmt{V}{D\to D'} \times \setmt{V}{D} \to \setmt{V}{D'},
\]
such that (for any~$p = (s, f)$ and~$q = (t, g)$ of matching types)
\[
  \apply_{\setcharmt}^{\odot} (p, q) = (a, b) ,
\]
where
\begin{eqnarray*}
  & a      = \{ h(x) \mid h \in s, x \in t \} , \\
  & b      = \{ v \mapsto b_1(v) \odot b_2(v) \mid v \in V \}, \\
  & b_1(v) = \apply_{\setcharmt}^{\odot}(p, g(v)), \\
  & b_2(v) = \apply_{\setcharmt}^{\odot}(f(v), q) .
\end{eqnarray*}
\end{Df}

In other words, to build a uniting or intersecting application of~$p$ to~$q$,
one should
\begin{itemize}
\item apply every function from the root node of~$p$ to every value from
the root node of~$q$, let the result be~$a$;
\item for every atomic name~$v\in V$, apply (in the sense that is being
described by this list) the entire multi-trie~$p$ of
functions to the $v$-child of the multi-trie~$q$ of values~-- let~$b_1(v)$ be
the result;
\item do the same with the $v$-child of~$p$ and the entire~$q$, let the result
be~$b_2(v)$;
\item merge $b_1(v)$ and $b_2(v)$ with the respective multi-trie operation
(union or intersection), let $b_1(v)\odot b_2(v) = b(v)$;
\item compose the resulting multi-trie from the set~$a$ of root values and a
name-to-child mapping~$b$.
\end{itemize}

Let us introduce infix aliases for the application operations to make
formulation of their properties more elegant (here and below~$\oplus$ means any
of~$\cup$, $\cap$ or~$\times$):
\[
  p \inapply{\oplus} q = \apply^{\oplus} (p, q) .
\]

\begin{St}\label{st:apply-distr}
Application operations distribute over set-theoretical operations.
For any~$p, p_1, p_2, q, q_1, q_2$ of matching types,
for $\odot \in \{\cup, \cap \}$ and $\oplus \in \{\cup, \cap, \times \}$,
\begin{eqnarray*}
  (p_1 \odot p_2) \inapply{\oplus} q =
    (p_1 \inapply{\oplus} q) \odot (p_2 \inapply{\oplus} q) , \\
  p \inapply{\oplus} (q_1 \odot q_2) =
    (p \inapply{\oplus} q_1) \odot (p \inapply{\oplus} q_2) .
\end{eqnarray*}
\end{St}

\section{Notes about implementation}

A container type implementing the multivalued naming with compound names has
been defined in Haskell programming language. Some trade-offs between the
mathematical purity and implementability could hardly be avoided. On the other
hand, the framework of fundamental concepts provided by Haskell gave a
direction towards some additional features that turn an abstract mathematical
object into a potentially useful member of Haskell programming world.

The mathematical construct described above formalizes manyvaluedness by means
of a \emph{set}: the value of $\deref$ function is a set of the name's values.
In Haskell programming, however, the most common representation of many-valued
functions is a function whose value is a \emph{list} of possible
values~\cite[p.~285]{bib:lipovaca}.  Using lists instead of sets gives some
benefits. For example, the many-valued function, as a value generator, does not
need to compare every newly produced value with all previous ones. Lists can be
generated by one function and consumed by another in a lazy manner. Elements'
type needs to be ordered for sets and does not for lists.

Therefore, the most significant difference between the mathematical constructs
and the software implementation is that an ambigious value of a compound name is
programmatically represented by a list of individual values.  From the
mathematical perspective, lists are closer to multisets than to sets because of
possibly duplicate elements.  Keeping in mind that a list-based implementation
is not isomorphic to the set-based specification, let us justify it as an
acceptable approximation.

There were two isomorphic though different formalisations: MVCNsets and
multi-tries. The former has higer abstraction level and suits well for
specification purposes whereas the latter involves a trie~-- a practical data
structure suitable for an efficient implementation. The only impractical
feature of multi-tries definition introduced for the sake of mathematical
simplicity is their infiniteness~-- every multitrie has a child node under
every atomic name; it allowed to simplify formulae omiting check whether the
name is in the trie.  In the trie-based implementation, however, it would be
better to store finite maps and perform such checks for the sake of efficiency.
In particular, if the underlying trie does not contain any child node for a
particular name, the objects behaviour observed via functions is the same as
if it associated this name with an empty multi-trie.

All this leads to the following basic definition (indeed, the module hides it
behind smart constructors).

\begin{lstlisting}
type MultiTrieMap n v = M.Map n (MultiTrie n v) 
data MultiTrie n v = MultiTrie {
        values :: [v],
        children :: MultiTrieMap n v }
\end{lstlisting}

The most important functions defined in the module are listed below.

\begin{lstlisting}
empty :: MultiTrie n v
top :: (Ord n, Bounded n, Enum n, Bounded v, Enum v) =>
    MultiTrie n v
leaf :: [v] -> MultiTrie n v
add :: v -> MultiTrie n v -> MultiTrie n v

values :: MultiTrie n v -> [v]
children :: MultiTrie n v -> MultiTrieMap n v
null :: MultiTrie n v -> Bool
size :: MultiTrie n v -> Int

isEqualStrict :: (Ord n, Eq v) =>
    MultiTrie n v -> MultiTrie n v -> Bool

subnode :: Ord n => [n] -> MultiTrie n v -> MultiTrie n v

mtmap :: Ord n => (v -> w) -> MultiTrie n v -> MultiTrie n w
cartesianProduct :: Ord n =>
    MultiTrie n v -> MultiTrie n w -> MultiTrie n (v, w)
union :: Ord n =>
    MultiTrie n v -> MultiTrie n v -> MultiTrie n v
flatten :: Ord n =>
    MultiTrie n (MultiTrie n v) -> MultiTrie n v

applyCartesian :: Ord n =>
    MultiTrie n (v -> w) -> MultiTrie n v -> MultiTrie n w
applyUniting :: Ord n =>
    MultiTrie n (v -> w) -> MultiTrie n v -> MultiTrie n w

toMap :: Ord n => MultiTrie n v -> Map [n] [v]
toList :: Ord n => MultiTrie n v -> [([n], v)]
fromList :: Ord n => [([n], v)] -> MultiTrie n v
\end{lstlisting}

Here is a shorh explanation of their semantics.
\begin{description}
\item [empty]
  A constant for the empty multi-trie~$\bot$, see def.~\ref{df:mvcn-extreme}
  and~\ref{df:mt-extreme}.
\item [top]
  A constant for the full multi-trie~$\bot$, see def.~\ref{df:mvcn-extreme}
  and~\ref{df:mt-extreme}.  The long class constraint is needed because the
  function must construct a (lazy) list of all names and a list of all possible
  values.
\item [leaf] Given a list of values, constructs a multi-trie that has this list
  in its root node and no other valies (i.e. all other names yield to an empty
  list of values).
\item [add]
  Given a value and a multi-trie, prepend the value to the list stored in the
  root node.
\item [values]
  Get a list of values from the root node of a multi-trie.
\item [children]
  From the root node of a multi-trie, get a mapping of atomic names to the
  child nodes.
\item [null]
  Check whether the argument multi-trie is empty.
\item [size]
  Get the total number of values in the multi-trie.
\item [isEqualStrict]
  Compare two multi-tries: they are considered equal if equal are lists of
  values under all compound names. I.e. if the multi-tries have equal lists
  of values in their root nodes and, for every atomic name, the corresponding
  child multi-tries are equal in this sense, in their turn. There is another
  function for weak comparison~-- it ignores order of elements in the lists
  treating them as multisets.
\item [subnode]
  Get a node pointed to by a compound name. If the name is not present in the
  underlying data structure, the function anyway yields a correct value, the
  empty multi-trie. This function implements selection operation from
  def.~\ref{df:mvcn-select} and~\ref{df:mt-select}.
\item [mtmap]
  Apply a function to each value in a multi-trie and combine results into
  a new multi-trie preserving the names (and, therefore, the trie structure),
  see def.~\ref{df:mvcn-map}.
  This is a specific implementation of the \lstinline{fmap} method from the
  \lstinline{Functor} class.
\item [cartesianProduct]
  Construct a cartesian product of two multi-tries in the sense of
  def.~\ref{df:mvcn-cartesian} and st.~\ref{st:deref-cartesian}.
\item [union]
  Construct a union of two multi-tries, see st.~\ref{st:mvcn-setop} and
  def.~\ref{df:mt-setop}. There is another function for intersection.
\item [flatten]
  Given a multi-trie whose values are, in their turn, multi-tries, construct
  a flattened multi-trie, see def.~\ref{df:flatten} and
  st.~\ref{st:deref-flatten}. This is a specific implementation of the
  \lstinline{join} function defined for all types of the \lstinline{Monad}
  class.
\item [applyCartesian]
  Cartesian
  application of a multi-trie of functions to a multi-trie of arguments, see
  def.~\ref{df:mt-apply-setop}.
\item [applyUniting]
  Uniting
  application of a multi-trie of functions to a multi-trie of arguments, see
  def.~\ref{df:mvcn-apply-cartesian}.
  There is also a dual function for intersection.
\item [toMap]
  Convert a multi-trie to a \lstinline{Data.Map} that maps compound names to
  lists of values. Corresponds to an inverse of the isomorphism~$\varphi$
  from st.~\ref{st:isomorph}.
\item [toList]
  Convert a multi-trie to a list of name--value pairs.
\item [fromList]
  Convert a list of name--value pairs to a multi-trie.
\end{description}

Finally, \lstinline{mtmap} function that implements the $\fmap$ operation
(def.~\ref{df:mvcn-map} and st.~\ref{st:map-properties})
makes \lstinline{MultiTrie} type an instance of the \lstinline{Functor} class; 
\lstinline{applyCartesian} function as an implementation of $\apply^{\times}$
operation makes it an instance of the \lstinline{Applicative} class; 
\emph{bind} operation not shown in this article is easy to define using mapping
and flattening operations~-- this makes the type an instance of the
\lstinline{Monad} class.



\section{Conclusion}

Having started with an intuitive notion of naming and its most general
formalisation, we moved to its special case with compound names and multiple
values. Two formalisations thereof were described: one based on the idea of
(ambigious) mapping of names to values as a whole and another based on
decomposing names into atoms. These definitions are shown to be essentially
equivalent. This equivalence, from the programmer's perspective, means that
this kind of containers could be used as a `plain' collection of name-value
pairs or as a hierarchical data structure.

A number of operations could be naturally defined for the namings in both
their interpretations: relational and trie-like. Most of the operations obey
such algebraic properties as associativity and/or distributivity over other
operations.

This naming concept leads to a software implementation that consists of an
underlying data structure roughly corresponding to a multi-trie formalisation
and a set of utility functions corresponding to the algebraic operations on
namings. The properties of operations described in the earlier sections fit
the multi-trie data type an instance of applicative functor and monad
typeclasses that makes multi-tries a member of Haskell container types,
together with lists, maps and trees.

As far as a list is a conventional model for a non-deterministic computation
that generates cases one by one in a lazy manner, a multi-trie could be used to
represent a non-deterministic multilevel structure unfolding when the consumer
needs more detail.
On the other hand, in the same way as a list could be \emph{simply a list},
a multi-trie could represent a static entity for which a tree of lists is a
natural form. A typical example could be a directory tree where an atomic name
corresponds to a subdirectory and values correspond to individual files.
A structure of an XML document is another example of such objects.



\begin{thebibliography}{00}

\bibitem{bib:frege}
  Gottlob Frege,
  \"Uber Sinn und Bedeutung.
  In: Zeitschrift f\"ur Philosophie und philosophische Kritik,
  NF~100. 1892, S.~25--50.

\bibitem{bib:wittgenstein}
  Ludwig Wittgenstein,
  Tractatus logico-philosophicus, Logisch-phi\-lo\-so\-phi\-sche Abhandlung.
  Suhrkamp,
  Frankfurt am Main,
  2003.

\bibitem{bib:quine}
  Quine, Willard Van Orman,
  Word and Object [1960].
  New edition, with a foreword by Patricia Churchland,
  Cambridge,
  Mass.: MIT Press,
  2015.

\bibitem{bib:ptop}
  Eric C.R. Hehner,
  A Practical Theory of Programming,
  2016-4-14 edition,
  http://www.cs.utoronto.ca/~hehner/aPToP/aPToP.pdf.

\bibitem{bib:utp}
  C.\,A.\,R.\,Hoare, He Jifeng,
  Unifying Theories of Programming,
  Prentice-Hall,
  1998.

\bibitem{bib:leroy}
  Xavier Leroy, Sandrine Blazy.
  Formal verification of a C-like memory model and its uses for verifying program transformations.
  Journal of Automated Reasoning.
  41(1), pp.1-31, July 2008.

\bibitem{bib:redko}
  Basarab~I., Nikitchenko~N., Red’ko~V.
  Compositional Databases.
  Kiev: Lybed’, 1992.~-- 191~p. (In Russian).

\bibitem{bib:ollongren}
  Alexander Ollongren,
  Definition of programming languages by interpreting automata.
  London: Academic Press,
  1974.

\bibitem{bib:dictionary}
  Paul~E.~Black,
  ``Dictionary'', in Dictionary of Algorithms and Data Structures [online],
  Vreda Pieterse and Paul E. Black, eds.
  Available from: http://www.nist.gov/dads/HTML/dictionary.html

\bibitem{bib:mehlhorn-assoc}
  Kurt Mehlhorn, Peter Sanders
  ``4: Hash Tables and Associative Arrays'',
  Algorithms and Data Structures: The Basic Toolbox
  Springer, pp.~81--98.

\bibitem{bib:knuth-trie}
  Donald Knuth,
  ``6.3: Digital Searching''.
  The Art of Computer Programming,
  Volume 3: Sorting and Searching (2nd ed.).
  Addison-Wesley. p.~492.


\bibitem{bib:lipovaca}
  Miran Lipova\v{c}a.
  Learn You Haskell for Great Good!
  360 pages,
  No Starch Press,
  2011.

\end{thebibliography}

\end{document}

